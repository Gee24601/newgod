<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <title>新神降临之日</title>
    <style>
        :root {
            /* 基础颜色变量 */
            --primary-color: #1a1a2e;
            --accent-color: #00f7ff;
            --text-color: #e1e1e1;
            
            /* 初始界面样式变量 */
            --true-ending-title-size: 1.8rem;
            --true-ending-content-size: 1.3rem;
            --false-ending-title-size: 1.6rem;
            --false-ending-content-size: 1.2rem;
            --ending-title-shadow: 0 0 15px currentColor;
            --ending-content-line-height: 1.6;
            --system-dialog-bg: rgba(40, 44, 52, 0.9);
            --system-dialog-border: #444;
            --emphasis-text-size: 1.4rem;
            --emphasis-text-color: #ffffff;
            --typing-speed: 100ms;
            
            /* 结局相关颜色 */
            --true-ending-color: #ffcc00;
            --false-ending-color: #ff6688;
            --true-ending-title-size: 1.8rem;
            --true-ending-content-size: 1.3rem;
            --false-ending-title-size: 1.6rem;
            --false-ending-content-size: 1.2rem;
            --ending-title-shadow: 0 0 15px currentColor;
            --ending-content-line-height: 1.6;
            
            /* 特殊段落样式参数 */
            --system-dialog-bg: rgba(40, 44, 52, 0.9);
            --system-dialog-border: #444;
            --emphasis-text-size: 1.4rem;
            --emphasis-text-color: #ffffff;
            --typing-speed: 100ms; /* 打字效果速度，越小越快 */
        }

        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            font-family: "Microsoft YaHei", sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #game-container {
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            background: rgba(26, 26, 46, 0.8);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 247, 255, 0.1);
            position: relative;
        }

        #story-text {
            font-size: 1.1rem;
            line-height: 1.8;
            margin-bottom: 2rem;
            min-height: 200px;
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 10px;
        }

        #story-text::-webkit-scrollbar {
            width: 5px;
        }

        #story-text::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        #story-text::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 10px;
        }

        .question-text {
            color: var(--accent-color);
            font-size: 1.2rem;
            font-weight: bold;
            margin: 1.5rem 0;
            padding: 0.5rem;
            border-left: 3px solid var(--accent-color);
            background: rgba(0, 247, 255, 0.1);
        }

        .selected-option {
            color: #a0a0a0;
            font-style: italic;
            padding: 0.5rem 1rem;
            margin: 0.5rem 0;
            border-left: 2px solid #a0a0a0;
            background: rgba(160, 160, 160, 0.1);
        }

        /* 真结局样式 */
        .true-ending {
            color: var(--true-ending-color);
            font-size: 1.5rem;
            text-align: center;
            padding: 2rem 1rem;
            margin: 2rem 0;
            border: 2px solid var(--true-ending-color);
            border-radius: 10px;
            background: rgba(255, 204, 0, 0.1);
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            position: relative;
        }

        .true-ending::before {
            content: "真结局";
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary-color);
            padding: 0 1rem;
            font-size: 1rem;
            color: var(--true-ending-color);
        }

        .ending-title {
            font-size: var(--true-ending-title-size);
            font-weight: bold;
            margin-bottom: 1.5rem;
            text-shadow: var(--ending-title-shadow);
        }

        .ending-content {
            font-size: var(--true-ending-content-size);
            line-height: var(--ending-content-line-height);
            text-align: left;
        }

        /* 真结局标题和内容样式 */
        .true-ending .ending-title {
            font-size: var(--true-ending-title-size);
        }

        .true-ending .ending-content {
            font-size: var(--true-ending-content-size);
        }

        /* 假结局样式 */
        .false-ending {
            color: var(--false-ending-color);
            font-size: 1.3rem;
            text-align: center;
            padding: 1.5rem 1rem;
            margin: 2rem 0;
            border: 1px dashed var(--false-ending-color);
            border-radius: 10px;
            background: rgba(255, 102, 136, 0.1);
            text-shadow: 0 0 8px rgba(255, 102, 136, 0.4);
            position: relative;
        }

        .false-ending::before {
            content: "结局";
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary-color);
            padding: 0 1rem;
            font-size: 0.9rem;
            color: var(--false-ending-color);
        }

        /* 假结局标题和内容样式 */
        .false-ending .ending-title {
            font-size: var(--false-ending-title-size);
        }

        .false-ending .ending-content {
            font-size: var(--false-ending-content-size);
        }

        /* Windows弹窗样式 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-window {
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.3);
            width: 450px;
            max-width: 90%;
            position: relative;
            animation: slideDown 0.3s ease-out;
            overflow: hidden;
            margin: 0 10px;
        }

        .modal-title-bar {
            background: linear-gradient(to right, #0078D7, #0063B1);
            color: white;
            padding: 10px 15px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
        }

        .modal-close-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .modal-content {
            padding: 20px;
            color: #333;
        }

        .modal-icon {
            float: left;
            margin-right: 15px;
            font-size: 32px;
        }

        .modal-message {
            margin: 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            min-height: 50px;
        }

        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* 系统弹窗样式 */
        .system-dialog {
            background: var(--system-dialog-bg);
            border: 1px solid var(--system-dialog-border);
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .system-dialog::before {
            content: "系统";
            position: absolute;
            top: -10px;
            left: 10px;
            background: var(--system-dialog-bg);
            padding: 0 0.5rem;
            font-size: 0.8rem;
            color: var(--accent-color);
            border-radius: 3px;
        }

        /* 强调文本样式 */
        .emphasis-text {
            font-size: var(--emphasis-text-size);
            font-weight: bold;
            color: var(--emphasis-text-color);
            text-align: center;
            padding: 1.5rem 1rem;
            margin: 2rem 0;
            border-left: 4px solid var(--accent-color);
            border-right: 4px solid var(--accent-color);
            background: rgba(0, 247, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 247, 255, 0.2);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            animation: pulse 2s infinite;
            position: relative;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(0, 247, 255, 0.2); }
            50% { box-shadow: 0 0 25px rgba(0, 247, 255, 0.4); }
            100% { box-shadow: 0 0 15px rgba(0, 247, 255, 0.2); }
        }

        /* 打字机效果样式 */
        .typing-text {
            display: inline-block;
            white-space: pre-wrap;
            overflow: hidden;
            border-right: 3px solid var(--accent-color);
            animation: cursor-blink 1s step-end infinite;
        }

        @keyframes cursor-blink {
            from, to { border-color: transparent }
            50% { border-color: var(--accent-color) }
        }

        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }
        
        /* 阅后即焚文本样式 */
        .burn-text {
            position: relative;
            padding: 0.8rem 1rem;
            margin: 1.2rem 0;
            border-left: 4px solid #ff4500;
            background: rgba(255, 69, 0, 0.08);
            font-family: monospace;
            transition: all 0.8s ease;
            color: #fff;
            text-shadow: 0 0 1px rgba(255, 69, 0, 0.7);
            font-size: 1.05rem;
            overflow: hidden;
        }

        .burn-text::before {
            content: "🔥";
            position: absolute;
            left: -10px;
            top: calc(50% - 10px);
            font-size: 16px;
        }

        .burn-text.burned {
            color: transparent;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
            background: rgba(255, 69, 0, 0.15);
            user-select: none;
            border-left-color: #772200;
            animation: burnEffect 2s ease-in forwards;
        }

        @keyframes burnEffect {
            0% { 
                text-shadow: 0 0 1px rgba(255, 255, 255, 0.9);
            }
            15% { 
                text-shadow: 0 0 3px rgba(255, 200, 50, 1);
                color: rgba(255, 255, 255, 0.9);
            }
            30% { 
                text-shadow: 0 0 6px rgba(255, 180, 50, 0.95);
                color: rgba(255, 255, 255, 0.8); 
            }
            50% { 
                text-shadow: 0 0 8px rgba(255, 120, 40, 0.95);
                color: rgba(255, 255, 255, 0.6); 
            }
            70% { 
                text-shadow: 0 0 12px rgba(255, 80, 30, 0.9);
                color: rgba(255, 255, 255, 0.4);
            }
            85% {
                text-shadow: 0 0 15px rgba(255, 50, 30, 0.9);
                color: rgba(255, 255, 255, 0.2);
            }
            100% { 
                text-shadow: 0 0 15px rgba(200, 0, 0, 0.85);
                color: transparent; 
            }
        }
        
        /* 初始界面样式 */
        #intro-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--primary-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        
        .intro-hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .container {
            max-width: 600px;
            width: 90%;
            text-align: center;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .title {
            font-size: 3.2rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            min-height: 4.5rem;
            color: var(--accent-color);
            text-shadow: 0 0 12px rgba(0, 247, 255, 0.5);
            width: 100%;
            line-height: 1.3;
            display: flex;
            justify-content: space-between;
        }

        .summary {
            font-size: 1.1rem;
            margin-bottom: 1.2rem;
            opacity: 0;
            transition: opacity 2s ease;
            width: 100%;
            text-align: center;
            display: block;
        }

        .title span {
            display: inline-block;
            margin: 0;
            padding: 0;
        }
        
        .summary span {
            display: inline-block;
            margin: 0 0.08em;
            padding: 0;
        }

        .credit {
            font-size: 1rem;
            margin-bottom: 2rem;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .start-btn {
            background-color: rgba(0, 247, 255, 0.1);
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            padding: 12px 30px;
            font-size: 1.5rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(20px);
        }

        .start-btn:hover {
            background-color: rgba(0, 247, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 247, 255, 0.5);
        }

        .start-btn.visible {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 1s ease, transform 1s ease;
        }

        /* 验证码弹窗样式 */
        .intro-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2001;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .intro-modal-window {
            background: #16162a;
            border: 1px solid var(--accent-color);
            border-radius: 10px;
            box-shadow: 0 0 25px rgba(0, 247, 255, 0.3);
            width: 350px;
            max-width: 90%;
            color: var(--text-color);
            overflow: hidden;
            transform: translateY(0);
            transition: all 0.3s ease;
            animation: modalAppear 0.3s ease;
        }

        @keyframes modalAppear {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .intro-modal-header {
            background: linear-gradient(135deg, #1a1a2e, #0f3057);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 247, 255, 0.2);
        }

        .intro-modal-header h3 {
            margin: 0;
            color: var(--accent-color);
            font-size: 1.2rem;
            font-weight: normal;
            letter-spacing: 1px;
        }

        .intro-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--accent-color);
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0;
            line-height: 1;
            opacity: 0.8;
        }

        .intro-modal-close:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .intro-modal-content {
            padding: 25px 20px;
            text-align: center;
        }

        .intro-modal-content p {
            margin: 0 0 20px;
            font-size: 0.95rem;
            opacity: 0.9;
        }

        .verification-input {
            width: 100%;
            padding: 12px;
            margin: 15px 0;
            border: 1px solid rgba(0, 247, 255, 0.3);
            border-radius: 6px;
            font-size: 1.1rem;
            text-align: center;
            letter-spacing: 8px;
            background: rgba(0, 0, 0, 0.2);
            color: var(--accent-color);
            transition: all 0.2s ease;
            box-sizing: border-box;
        }

        .verification-input:focus {
            outline: none;
            border: 1px solid var(--accent-color);
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.3);
        }
        
        .verification-input::placeholder {
            color: rgba(225, 225, 225, 0.5);
            letter-spacing: 2px;
        }

        .intro-modal-footer {
            padding: 10px 20px 20px;
            text-align: center;
            border-top: none;
        }

        .verify-btn {
            background: linear-gradient(135deg, #00c2ff, #0063a7);
            border: none;
            color: white;
            padding: 10px 30px;
            font-size: 1rem;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 194, 255, 0.3);
        }

        .verify-btn:hover {
            background: linear-gradient(135deg, #00d2ff, #0082c9);
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(0, 194, 255, 0.4);
        }
        
        .verify-btn:active {
            transform: translateY(1px);
        }

        .error-message {
            color: #ff4f6f;
            font-size: 0.9rem;
            margin-top: 10px;
            display: none;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }

        .burn-text.burned::after {
            content: "[该内容已销毁]";
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 69, 0, 0.7);
            font-style: italic;
            text-shadow: none;
            font-size: 1.2rem;
            opacity: 0;
            animation: showDestroyed 0.5s ease-in 1.9s forwards;
        }

        @keyframes showDestroyed {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* 触摸设备交互优化 */
        @media (hover: none) and (pointer: coarse) {
            .option-button, .start-btn, .verify-btn, #restart-button, 
            .modal-close-btn, .intro-modal-close {
                min-height: 44px; /* 苹果推荐的最小触摸区域高度 */
            }
            
            .modal-close-btn, .intro-modal-close {
                padding: 8px;
                font-size: 26px;
            }
            
            .option-button:active {
                background: var(--accent-color);
                color: var(--primary-color);
            }
        }
        
        /* 移动设备响应式样式 */
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            #game-container {
                max-width: 100%;
                padding: 1rem;
                border-radius: 8px;
            }
            
            #story-text {
                font-size: 1rem;
                line-height: 1.6;
                max-height: 60vh;
            }
            
            .option-button {
                padding: 0.8rem 1.2rem;
                font-size: 0.95rem;
                margin-bottom: 0.5rem;
            }
            
            .true-ending, .false-ending {
                padding: 1.5rem 0.8rem;
                margin: 1.5rem 0;
            }
            
            .true-ending .ending-title, .false-ending .ending-title {
                font-size: calc(var(--true-ending-title-size) * 0.9);
                margin-bottom: 1rem;
            }
            
            .true-ending .ending-content, .false-ending .ending-content {
                font-size: calc(var(--true-ending-content-size) * 0.95);
            }
            
            .modal-window {
                width: 90%;
                max-width: 350px;
            }
            
            #items-container {
                margin-top: 1.5rem;
            }
            
            .container .title {
                font-size: 2.5rem;
            }
            
            .container .summary {
                font-size: 1rem;
            }
            
            .start-btn {
                padding: 10px 25px;
                font-size: 1.3rem;
            }
            
            .intro-modal-window {
                width: 90%;
                max-width: 320px;
            }
        }
        
        /* 小屏幕设备的额外样式 */
        @media screen and (max-width: 480px) {
            html, body {
                overscroll-behavior: none; /* 防止iOS上的弹性滚动 */
            }
            body {
                padding: 5px;
                padding-top: env(safe-area-inset-top, 5px);
                padding-bottom: env(safe-area-inset-bottom, 5px);
            }
            
            #game-container {
                padding: 0.8rem;
                box-shadow: 0 0 15px rgba(0, 247, 255, 0.08);
            }
            
            #story-text {
                font-size: 0.95rem;
                margin-bottom: 1.5rem;
            }
            
            .question-text {
                font-size: 1.05rem;
                padding: 0.4rem;
            }
            
            .selected-option {
                padding: 0.4rem 0.8rem;
            }
            
            .option-button {
                padding: 0.7rem 1rem;
                font-size: 0.9rem;
            }
            
            .true-ending .ending-title, .false-ending .ending-title {
                font-size: calc(var(--true-ending-title-size) * 0.8);
            }
            
            .true-ending .ending-content, .false-ending .ending-content {
                font-size: calc(var(--true-ending-content-size) * 0.9);
            }
            
            .modal-content {
                padding: 15px;
            }
            
            .item {
                padding: 4px 8px;
                font-size: 0.9rem;
            }
            
            .container .title {
                font-size: 2.2rem;
                margin-bottom: 1.2rem;
            }
            
            .verify-btn {
                padding: 8px 22px;
            }
            
            /* 游戏控制区域 */
            #game-controls {
                flex-direction: column;
                gap: 8px;
                align-items: center;
            }
            
            #restart-button {
                margin-bottom: 5px;
            }
        }
        
        /* 禁用的选项按钮样式 */
        .option-button.disabled {
            background: rgba(80, 80, 80, 0.2);
            border: 2px solid rgba(80, 80, 80, 0.5);
            color: rgba(150, 150, 150, 0.7);
            cursor: not-allowed;
            position: relative;
        }

        .option-button.disabled::after {
            content: "🔒";
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            opacity: 0.7;
        }

        .option-button.disabled:hover {
            background: rgba(80, 80, 80, 0.3);
            color: rgba(150, 150, 150, 0.8);
        }

        #options-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .option-button {
            background: transparent;
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            padding: 1rem 2rem;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 5px;
        }

        .option-button:hover {
            background: var(--accent-color);
            color: var(--primary-color);
        }

        #items-container {
            margin-top: 2rem;
            padding: 1rem;
            border-top: 1px solid var(--accent-color);
        }

        .fade-in {
            animation: fadeIn 1s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* 游戏控制和信息 */
        #game-controls {
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
        }
        
        #restart-button {
            background: transparent;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 0.3rem 0.7rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 3px;
        }
        
        #restart-button:hover {
            background: var(--accent-color);
            color: var(--primary-color);
        }
        
        /* 加载屏幕 */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--primary-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s ease;
        }
        
        #loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 247, 255, 0.2);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #loading-text {
            margin-top: 1rem;
            color: var(--accent-color);
            font-size: 1.2rem;
        }
    </style>
</head>
<body>
    <!-- 初始界面 -->
    <div id="intro-container">
        <div class="container">
            <h1 class="title" id="game-title"></h1>
            <div class="summary" id="game-summary">Summary：藏在七重纱下，他的过去像死亡一样迷人。</div>
            <div class="credit" id="game-credit">制作：不嗑真的、刺</div>
            <button class="start-btn" id="start-btn">游戏开始</button>
        </div>
    </div>
    
    <!-- 验证码弹窗 -->
    <div class="intro-modal-overlay" id="verification-modal">
        <div class="intro-modal-window">
            <div class="intro-modal-header">
                <h3>安全验证</h3>
                <button class="intro-modal-close" id="intro-modal-close">&times;</button>
            </div>
            <div class="intro-modal-content">
                <p>请输入验证码以继续游戏</p>
                <input type="text" id="verification-code" class="verification-input" maxlength="6" placeholder="请输入验证码">
                <div class="error-message" id="error-message">验证码错误，请重试</div>
            </div>
            <div class="intro-modal-footer">
                <button class="verify-btn" id="verify-btn">验证</button>
            </div>
        </div>
    </div>

    <!-- 加载屏幕 -->
    <div id="loading-screen" style="display: none;">
        <div id="loading-spinner"></div>
        <div id="loading-text">给茶茶的机箱盖烫精美卷盖中～</div>
    </div>

    <div id="game-container" style="display: none;">
        <div id="story-text"></div>
        <div id="options-container"></div>
        <div id="items-container"></div>
        <div id="game-controls">
            <button id="restart-button">重新开始</button>
            <div id="game-info">刺处是llc产嗑工作室</div>
        </div>
    </div>

    <!-- Windows风格模态弹窗 -->
    <div id="modal-overlay" class="modal-overlay">
        <div class="modal-window">
            <div class="modal-title-bar">
                <span id="modal-title">系统提示</span>
                <button class="modal-close-btn" id="modal-close">&times;</button>
            </div>
            <div class="modal-content">
                <div class="modal-icon">&#9888;</div>
                <p class="modal-message" id="modal-message">系统消息内容</p>
            </div>
        </div>
    </div>
    
    <!-- 广告复活选项弹窗 -->
    <div id="revive-modal-overlay" class="modal-overlay">
        <div class="modal-window">
            <div class="modal-title-bar">
                <span>复活选择</span>
                <button class="modal-close-btn" id="revive-modal-close">&times;</button>
            </div>
            <div class="modal-content">
                <div class="modal-icon">🔄</div>
                <p class="modal-message">你想要观看广告获得复活机会吗？</p>
                <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                    <button id="revive-yes-btn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">是</button>
                    <button id="revive-no-btn" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">否</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 广告内容弹窗 -->
    <div id="ad-modal-overlay" class="modal-overlay">
        <div class="modal-window" style="width: 500px; max-width: 95%;">
            <div class="modal-title-bar">
                <span id="ad-modal-title">广告</span>
                <button class="modal-close-btn" id="ad-modal-close">&times;</button>
            </div>
            <div class="modal-content">
                <h2 id="ad-title" style="text-align: center; margin-top: 0;">广告标题</h2>
                <div id="ad-content" style="margin: 15px 0;">广告内容</div>
                <div style="text-align: center; margin-top: 15px;">
                    <button id="ad-close-btn" style="padding: 8px 20px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">关闭广告</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    // 初始界面和验证码逻辑
    document.addEventListener('DOMContentLoaded', function() {
        const introContainer = document.getElementById('intro-container');
        const gameContainer = document.getElementById('game-container');
        const loadingScreen = document.getElementById('loading-screen');
        const gameTitle = document.getElementById('game-title');
        const gameSummary = document.getElementById('game-summary');
        const gameCredit = document.getElementById('game-credit');
        const startBtn = document.getElementById('start-btn');
        const verificationModal = document.getElementById('verification-modal');
        const introModalClose = document.getElementById('intro-modal-close');
        const verifyBtn = document.getElementById('verify-btn');
        const verificationCode = document.getElementById('verification-code');
        const errorMessage = document.getElementById('error-message');

        const titleText = "新神降临之日";
        
        // 初始化：预先创建标题的所有字符，并设置为不可见
        gameTitle.innerHTML = '';
        const titleChars = titleText.split('');
        titleChars.forEach(char => {
            const span = document.createElement('span');
            span.textContent = char;
            span.style.display = 'inline-block';
            span.style.opacity = '0';
            gameTitle.appendChild(span);
        });
        
        const titleSpans = gameTitle.querySelectorAll('span');
        let index = 0;

        // 逐个显示标题文字
        function typeTitle() {
            if (index < titleSpans.length) {
                titleSpans[index].style.opacity = '1';
                index++;
                setTimeout(typeTitle, 200); // 每200毫秒显示一个字符
            } else {
                // 标题显示完后，直接显示摘要
                setTimeout(() => {
                    // 处理摘要的两端对齐
                    const summaryText = gameSummary.textContent;
                    const summaryChars = summaryText.split('');
                    gameSummary.innerHTML = '';
                    summaryChars.forEach(char => {
                        const span = document.createElement('span');
                        span.textContent = char;
                        span.style.display = 'inline-block';
                        gameSummary.appendChild(span);
                    });
                    
                    gameSummary.style.opacity = "1";
                    
                    // 摘要显示后，显示制作信息
                    setTimeout(() => {
                        gameCredit.style.opacity = "1";
                        
                        // 制作信息显示后，显示开始按钮
                        setTimeout(() => {
                            startBtn.classList.add('visible');
                        }, 1000);
                    }, 1000);
                }, 500);
            }
        }

        // 开始显示标题
        typeTitle();

        // 点击开始按钮，显示验证码弹窗
        startBtn.addEventListener('click', function() {
            verificationModal.style.display = 'flex';
            verificationCode.focus();
            errorMessage.style.display = 'none';
        });

        // 关闭验证码弹窗
        introModalClose.addEventListener('click', function() {
            verificationModal.style.display = 'none';
            errorMessage.style.display = 'none';
            verificationCode.value = '';
        });

        // 验证按钮点击
        verifyBtn.addEventListener('click', verifyCode);
        
        // 输入框回车事件
        verificationCode.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                verifyCode();
            }
        });

        // 验证码检查函数
        function verifyCode() {
            const code = verificationCode.value.trim();
            if (code === '804304') {
                // 验证成功，隐藏初始界面和验证码弹窗，显示游戏界面
                verificationModal.style.display = 'none';
                introContainer.classList.add('intro-hidden');
                
                // 延迟后完全隐藏初始界面并显示游戏
                setTimeout(() => {
                    introContainer.style.display = 'none';
                    gameContainer.style.display = 'block';
                    
                    // 显示加载页面
                    loadingScreen.style.display = 'flex';
                    
                    // 初始化游戏
                    setTimeout(() => {
                        initializeGame();
                    }, 500);
                }, 600);
            } else {
                // 验证失败，显示错误信息
                errorMessage.style.display = 'block';
                verificationCode.value = '';
                verificationCode.focus();
            }
        }
    });

    // 游戏初始化函数
    function initializeGame() {
        console.log("初始化游戏...");
        
        // 重置游戏状态
        currentState = {
            currentParagraphIndex: 0,
            paragraphQueue: [],
            displayedParagraphs: [],
            isShowingOptions: false,
            playerChoices: [],
            items: [],
            isModalOpen: false,
            burnTextElements: [],
            hasRevived: false,
            revivedFromEnding: null
        };
        
        // 预处理游戏数据
        const dataReady = prepareGameData();
        
        if (dataReady) {
            // 确保从第一个段落开始
            initializeParagraphQueue();
            console.log("初始段落队列:", currentState.paragraphQueue);
            
            // 清空故事文本区域
            document.getElementById('story-text').innerHTML = '';
            
            // 隐藏加载页面
            setTimeout(() => {
                document.getElementById('loading-screen').style.opacity = "0";
                setTimeout(() => {
                    document.getElementById('loading-screen').style.display = "none";
                    // 开始显示故事
                    advanceStory();
                    updateItemsDisplay();
                }, 500);
            }, 1000);
        } else {
            // 数据准备失败
            document.getElementById('loading-screen').style.display = "none";
            alert("游戏数据加载失败，请刷新页面重试。");
        }
    }
    
    // 游戏数据
    // ---------- 游戏数据开始 ----------
   

const gameData = {
    paragraphs: {
        P001: [
            "潘展乐的人生像任何一个二十岁年轻人一样乏善可陈，如果一定要说的话，他曾经在几百年前留下的信息里看见过和自己同名同姓的游泳运动员。"
        ],
        P002: [
            "对此潘展乐仅有轻微的好奇，随着科技过度的发展，人类的生存空间像海绵里的水一样越挤越少。"
        ],
        P003: [
            "“运动”“竞技”以及由此而来的精神财富都被科技消磨殆尽，活下来的人类更想智械操控下的空壳，在万寿无疆的无形暴君之领导下，效仿着超越人类的智能机械地活着。"
        ],
        P004: [
            "“这也太巧了。”潘展乐将手机屏幕朝下扣在了床头，小声嘟囔了一句。"
        ],
        P005: [
            "和潘展乐同住的是一台洗碗机，他霸占了这间小公寓大部分的网络，所以潘展乐用不了更新的人工智能，只能用老古董手机取悦自己。"
        ],
        P006: [
            "在这个时代洗碗机很显然不需要为人类吃饭的物理碗筷服务，他的信号遍布整个街区，以潘展乐的房间这一基站为圆心覆盖100平方米的圆形区域，为高贵的智能生命提供赛博碗筷上作为“污垢”的数据的清理。"
        ],
        P007: [
            "当然，这间房间的物理空间也不会因此腾出许多给潘展乐，事实上大部分空间都被洗碗机的基站占领，作为报答他许诺，只要潘展乐幻想出需要洗的盘子，他会替潘展乐洗掉赛博污垢。"
        ],
        P008: [
            "洗碗机高兴坏了，现在它不用做欺负人类的坏电电！它决心一三五变成奶牛猫，二四六变成布偶猫，剩下的日子都做三花大美女弥补潘展乐。日子就这样过去。"
        ],
        P009: [
            "这肯定不行！潘展乐摸了摸自己的脑袋，觉得一只猫是底线而十只猫未必是上限。不知道为什么，他总觉得能和喜欢的人一起喂猫是天底下最幸福的事情。"
        ],
        P010: [
            "潘展乐觉得这个世界很无趣。"
        ],
        P011: [
            "他最大的乐趣是看一些属于古代（相对于这个时代的古代）留存下来的资料，他喜欢大自然，喜欢人与人的交流，而不是只有冰冷的器械。"
        ],
        P012: [
            "这个时代的人类想得到一份工作并不容易，潘展乐现在的工作是在幼儿园做老师。"
        ],
        P013: [
            "因为不需要太多的人，这个时代大多数普通人都已经完成绝育，把子宫替换成能供养人工智能生命存活的基站房间或者能够吐出能源的发电站，把阴茎替换成可以与人工智能连接读取数据的生命权杖，这才是高性价比的做法。"
        ],
        P014: [
            "只有少数权贵仍然生育了下一代，他们向电子的暴君俯首称臣，代替人类情感匮乏的智能统治人类，以此交换权柄。"
        ],
        P015: [
            "“那么人工智能统治者之上呢？”潘展乐抱着自己怀里的孩子，操作着他的人工智能腕表，替他讲解这个时代人尽皆知的秘密。"
        ],
        P016: [
            "“还有一位电子神明。”"
        ],
        P017: [
            "或许电子亦有电子的救赎，高悬于互联网的电子神明是所有人工智能和残存人类的共同信仰。"
        ],
        P018: [
            "他真正做到了无孔不入，只要有一点最微弱的信号就足以让他窥探到你的一切奥秘。"
        ],
        P019: [
            "哪怕是最微小的思想触角，也会被智能思想识别系统检索到，只要有反叛的行为，就可以对其进行电子死刑，从此之后无论是基站轮转的智械还是肉身尚存的人类，终其生命周期都无法连接任何互联网，成为真正与世隔绝的孤岛。"
        ],
        P020: [
            "过于辛辣的事实不适合给孩子讲述，潘展乐用童话的语言描述了一个戴着尖尖金色帽子的漂亮神明。"
        ],
        P021: [
            "结束了一天的工作，潘展乐想起来自己在这里仅存的一个朋友。"
        ],
        P022: [
            "上一次朋友来找他，好像已经过去了一个月的时间。"
        ],
        P023: [
            "不过这并不少有，毕竟大家更多通过互联网联络感情，现在的技术已经足够发达，只要想甚至一个4D触感电话就能让彼此身边生出一个对方，哪怕要做爱也完全可以实现。"
        ],
        P024: [
            "潘展乐想去找朋友，其中原因很简单，他攒了一个月的工资买了一份古法人类食物，不是只能勉强填饱肚子食之无味的营养剂，而是一碗色香味俱全的温州年糕。"
        ],
        P025: [
            "想着朋友一定也喜欢吃，他乘了一个多小时的星际列车到了朋友家里。"
        ],
        P026: [
            "一打开朋友的门，潘展乐就听见朋友神秘兮兮的声音：“快进来，我也有个好东西要给你看呢。”"
        ],
        P027: [
            "潘展乐被对方紧张而激动的神情吸引，他连忙一把关上了门：“什么啊，给我看看？”"
        ],
        P028: [
            "朋友特意拉住了窗帘，他摊开手掌，掌心朝上，里面是一片小小的芯片。"
        ],
        P029: [
            "潘展乐心里咯噔一声，他抬起头看向朋友，突然想起来朋友已经做了局部躯体机械化，现在他的半个脑子和一整条手臂都已经被机械取代，其中大部分都保持了人类本来的面目，只有手臂上一块为了炫酷，保留了机械的外观。"
        ],
        P030: [
            "现在朋友就把这一块小小放进了自己手臂里的读卡器，随即芯片发出一阵霓虹般七彩的光。"
        ],
        P031: [
            "潘展乐不知道此刻在朋友眼里自己是什么样的，他只能通过朋友幸福得迷离失去神志的眼神判断，这就好像古代人类会去一个叫“滇”的地方吃菌子，吃了之后整个人就有可能出现仿佛高出原有生命维度的幻觉。"
        ],
        P032: [
            "他朋友的状态大抵如此。"
        ],
        P033: [
            "他服下了赛博菌子。"
        ],
        P034: [
            "潘展乐震惊地看着朋友，意识到已经过去了十分钟。"
        ],
        P035: [
            "朋友这才把那块芯片取出来。"
        ],
        P036: [
            "被取出来的芯片已经失去了原本五彩斑斓的绚丽色彩，只剩下一点点模糊的光芒。"
        ],
        P037: [
            "朋友靠在沙发上，恍惚思考了很久才餍足地叹了口气：“真他主机的爽啊。”"
        ],
        P038: [
            "他说完两眼放空了半天，小心翼翼从口袋里拿出一小片芯片，递到了潘展乐手上：“拿去吧，我专门给你也买了一个，太舒服了我说真的，这辈子没这么爽过，你别推辞，我知道你小子现在没做改造，但是认真的，被改造才是大势所趋，你快试试吧。”"
        ],
        P039: [
            "潘展乐还想推辞，可是朋友已经把他两只手往里一包：“跟我你客气什么，只不过别让教会的机械知道，我今天断了网才敢找你的哈。”"
        ],
        P040: [
            "那天的饭他们吃得索然无味，至少朋友是这样，潘展乐还是吃得很开心，可是潘展乐看向自己的发小，知道他已经有了更快乐的东西。"
        ],
        P041: [
            "这对潘展乐来说也是打开了新世界的大门，现在他第一次了解到自己手里小小的芯片。"
        ],
        P042: [
            "它是一个全新的程序，能够把改造了身体的人类所有的改造部件都调动起来，一半对着大脑输出幸福的信号，另一半生成幸福的程序。"
        ],
        P043: [
            "这是一种生物与机械的双重高潮。"
        ],
        P044: [
            "因为其原理，改造越彻底、越接近机器人的人，感觉到的快乐就越多。"
        ],
        P045: [
            "当然，这无疑是教会不许的。"
        ],
        P046: [
            "电子神明的理念一向是“真心换真心”，改造越强越接近机械是一种为适者生存的达尔文主义。"
        ],
        P047: [
            "这是不正确的。"
        ],
        P048: [
            "潘展乐把芯片压在口袋最底下，心想千万不敢被周围的人发现这一点，他还需要这份工作，让他能够租赁这间只能勉强落脚的房间。"
        ],
        P049: [
            "可惜天不遂人愿，至少在保守秘密上，他从不放弃折磨每一个心怀鬼胎的人。"
        ],
        P050: [
            "潘展乐在一个雨过天晴的日子被拉去教会问话。"
        ],
        P051: [
            "觐见一位赛博神父之前需要进行一场赛博法事，潘展乐的尾指上被系了一小段电池，这是所谓“饮圣血”，随后他被要求登录到一个熟悉的系统，这是所谓的“用圣体”。"
        ],
        P052: [
            "走进殿堂的时候潘展乐身上没有任何一件电子设备，这是为了防止人类功能落后的电子设备上携带古老的病毒，污染神父的主机。"
        ],
        P053: [
            "可是现在潘展乐面前的不是每个礼拜都要参见的神父系统，这大殿白茫茫、空荡荡的，四下什么都没有，只有一点金色的光圈在半空中闪耀着，随后是一段清脆的代码声音。"
        ],
        P054: [
            "潘展乐感觉眼前一阵强光，随即一个醒目的年轻男人出现在他面前。"
        ],
        P055: [
            "潘展乐大吃一惊，他愣了一下，才关注到男人发型精致，脸颊漂亮，眼神清净，穿着一件白色托加长袍，和旧日的神明一样让人有种强烈地跪拜冲动。"
        ],
        P056: [
            "潘展乐咽了下口水，他微微后退一步，听见一个声音在他脑海中想起：“我看到了，你私藏了芯片。和我说实话，好不好？”"
        ],
        P057: [
            "作为一个幼师，潘展乐没少和小孩子说“好不好”这样带着宠爱意味的话，他在震惊于对方悄无声息地入侵自己的思维时，一边震撼地意识到，这或许就是至高无上的电子神明。"
        ],
        P058: [
            "他身上无一个机械部件，这一刻却察觉到了埋植芯片的快乐，远胜自己的朋友千百倍。"
        ],
        P059: [
            "潘展乐呆呆站在原地，半晌才说：“你看到了。”"
        ],
        P060: [
            "他听到一阵很可爱的笑声从他大脑传出来，电子神明说：“可是我想听你自己说出来呀。”"
        ],
        P061: [
            "潘展乐从未觉得自己如此僵硬。"
        ],
        FE001: [
            "[结局：局外人]|||我知道你其实不是出卖朋友的人，只不过想看看会怎样，那就看吧——天降正义！|||你获得了少量工作，白天放牛晚上摘茶叶，充实的嘞。"
        ],
        P062: [
            "他颤抖着声音说：“是我一个人，我买的，我想试试。”"
        ],
        P063: [
            "他没有出卖自己的朋友，一半是因为义气，一半是不想这金光闪闪的神明看见别人。"
        ],
        P064: [
            "随即他听见神明传来一阵金色的叹息，他感觉到一点点并不过于火热的温度从自己头顶传来。"
        ],
        P065: [
            "那电子神说。"
        ],
        P066: [
            "“乖孩子。”"
        ],
        P067: [
            "潘展乐的呼吸被短暂地凝滞住，他屏住呼吸，看着面前，那里已经不再有电子神明，只有雪白的基站。"
        ],
        P068: [
            "随后他听见那声音说：“这孩子和我有缘，留下来吧。”"
        ],
        P069: [
            "然后是一阵漫长的黑暗。"
        ],
        P070: [
            "等潘展乐醒过来时，他注意到自己的小腹在隐隐作痛。"
        ],
        P071: [
            "潘展乐低下头，看见在他的腹股沟——如果再往下一点，这个位置会影响到他安装生命权杖——出现了一道轻飘飘的刺青。"
        ],
        P072: [
            "他认不得这个图案是什么，只觉得四四方方，不是新时代通字。"
        ],
        P073: [
            "感觉到潘展乐醒了，整个房间里的智械都吵闹起来了：“好幸运的人类，不知道他走了什么屎山代码运，被神留在了身边。”"
        ],
        P074: [
            "“不是所有机都可以留下这个标记的好不好？”"
        ],
        P075: [
            "“他会成为神的存储器里一件漂亮的装饰品。”"
        ],
        P076: [
            "作为一个没有人工智能的破落户，潘展乐第一次同时见到这么多智械在讲话。"
        ],
        P077: [
            "他很想说点什么，就听见电子的神明对着他微笑：“好孩子，到我身边来。”"
        ],
        P078: [
            "潘展乐没法控制自己的腿，这不是任何神迹，他只是深深地被吸引。"
        ],
        P079: [
            "他头一次理解了那些赛博朝圣后的人们为何有了坚定的信仰。"
        ],
        P080: [
            "因为被留下来给神的基站上硅油（其实神或者其他智械都可以做到，这只是一份偏爱），潘展乐不再需要每个星期向神父忏悔，发那些一长串的忏悔邮件，有的时候还要给偷懒的神父一串代码，让他能直接生成一个净化自己的小程序。"
        ],
        P081: [
            "每个星期编自己的错误太难了！"
        ],
        P082: [
            "潘展乐就这样住进了神的金花园中。"
        ],
        P083: [
            "每天中午他休息的时候，神就会悄悄降临在他身旁。这时候潘展乐是知道的，他能感觉到自己的额头被神安放在膝盖上。"
        ],
        P084: [
            "如果一个电子神明有这东西的话。"
        ],
        P085: [
            "在这里住了几个月，潘展乐终于知道了神的名字。"
        ],
        P086: [
            "可惜也不是神本人告诉他的，潘展乐有一天代替神整理他的房间，意外发现了一盒人类的物件。"
        ],
        P087: [
            "打开看的时候，潘展乐看到了来自几百年前的物品。"
        ],
        P088: [
            "或许是神有属于自己的神力，他竟然保存这些东西如此久。"
        ],
        P089: [
            "潘展乐翻开这些脆而硬的纸张，是一些2020年一直到之后十几年的报道，看到上面那张熟悉的面孔时，潘展乐第一次读出来这个名字。"
        ],
        P090: [
            "“张博恒。”"
        ],
        P091: [
            "里面还有几件衣服，同样看上去颇有古董的氛围感，可惜这个时代人工智能的暴君无意人文关怀或者机文关怀，对这些饱含年代感的东西毫无兴趣。"
        ],
        P092: [
            "因此它们也只能静静地躺在神的箱奁中，连同那个名字一同沉寂于尘封的记忆。"
        ],
        P093: [
            "“张博恒。”这是潘展乐第一次喊出他的名字，他看见神的投影因为信号的波动而颤抖了一下。"
        ],
        P094: [
            "神，或许现在也可以叫他张博恒，对着潘展乐微笑起来：“是我呀。”"
        ],
        P095: [
            "“还有其他人叫你这个名字吗？”潘展乐跟在他身后问道，张博恒本人个子不高，幻化的投影也矮潘展乐一头。"
        ],
        P096: [
            "此刻，他正认真地回过头来对着潘展乐答道：“你想要其他人也这么称呼我吗？”"
        ],
        P097: [
            "无所谓，”潘展乐毫不犹豫地说，这话刚出口，他就后悔了，可是已经来不及修改，只能看着张博恒的方向。"
        ],
        P098: [
            "张博恒歪过头，对他笑了一下：“真的吗？感觉有什么东西比钻石更坚硬呢。”"
        ],
        P099: [
            "潘展乐下意识地捂住了自己的嘴，这下好了，谁都知道他真实的答案是什么了。"
        ],
        P100: [
            "潘展乐迟疑了一下回答道：“这能说吗，我不想。”"
        ],
        P101: [
            "他于是看到张博恒笑起来：“好啊，那就只许你叫。”"
        ],
        P102: [
            "作为这个信息过度发达的时代唯一的神明，张博恒其实拥有众多的信徒。"
        ],
        P103: [
            "潘展乐按照系统上一个个核对信徒的名单，好像就看到了整个世界。"
        ],
        P104: [
            "他是人类，处理这些其实远没有机器灵巧，可是能帮到张博恒他很开心。"
        ],
        P105: [
            "偏偏就在他开心地工作时，有不速之客闯进了他的房间。"
        ],
        P106: [
            "按照潘展乐作为人类的习惯，他会说：有人闯进了他的房间。"
        ],
        P107: [
            "可是实际上，他是张博恒彻彻底底的同类，是人工智能4D影像的产物。"
        ],
        P108: [
            "潘展乐皱着眉头看向自己面前的智能：“你没事吧？”"
        ],
        P109: [
            "对面显然不是什么特别高级的机械，他麻木地对潘展乐说：“我有关于我们的神的话要和你说，他花了太多时间和精力在人类身上。我的母机留给我的程序认我分析出来，这是不对的。所以我有一个真相要告诉你，希望你可以主动离他远点。”"
        ],
        P110: [
            "潘展乐说：“你用的哪个模组，怎么分析出来我就要远离他呢？”"
        ],
        P111: [
            "他说完，听到对面没什么感情的声音想起来：“你要听吗？”"
        ],
        P112: [
            "潘展乐当然选择听。"
        ],
        P113: [
            "他从来没怀疑过自己的感情，也不觉得有任何一个因素会影响到他的敬爱之心。"
        ],
        P114: [
            "所以他没想到，在他对面，年轻的智械问他播放的是更古老的影像。"
        ],
        P115: [
            "那是一段以现在的视角看智能说落后的2D视频，但是他依然能从视频上看见张博恒的意气风发。"
        ],
        P116: [
            "他看见张博恒伸直手臂，对着天空做出示意的动作，下一刻，镜头轮转，他和张博恒擦肩而过的一瞬间，那双多情的眼睛落在他肩膀上。"
        ],
        P117: [
            "潘展乐蓦地停止呼吸，他想起自己还没有来到这个时间前，曾经是个游泳运动员。"
        ],
        P118: [
            "他清晰地记得那一套泳裤，记得那一片水，那是杭州亚运会的场地，他意气风发地打破纪录，而与他擦肩而过的张博恒一站四金。"
        ],
        P119: [
            "潘展乐几乎要忘记张博恒，或者说来到这个时间久了，他对原本的人事物都只剩下了模糊的回忆。"
        ],
        P120: [
            "这个时代要处理的信息太多，他大脑的宫殿里已经存不下这样多的东西。"
        ],
        P121: [
            "可是他又模糊地想起来什么，他记起来了，那是一次再普通不过的学习会议，张博恒就坐在他身边，耳朵红红的，眼睛亮亮的。"
        ],
        P122: [
            "随即画面一转，他看到张博恒正躺在床上，手机里随意地翻看着什么，潘展乐从后面细看，发现他正在浏览一个分析两个人为什么是天作之合的“命之星”的发帖，嘴角露出一丝微笑。"
        ],
        P123: [
            "随即他看到，张博恒拿起一个本子，这个本子他刚刚才看到，是两个人坐在一张桌子上时用的。"
        ],
        P124: [
            "张博恒在本子的角落画了一只小小的考拉，他大约真的不够聪明，画得考拉像一只大老鼠，灰头土脸的不知道是不是要偷走谁的幸福。"
        ],
        P125: [
            "潘展乐的脸一下子红透了，他转过身不去看了，说道：“这是我和张博恒的事情，总有一天我要亲自问他的，你出去吧。”"
        ],
        P126: [
            "他说着“啪”一下切断了这边房间的网络，在这个真正的网络时代，这是大不敬，但是那怎么样呢，潘展乐无所谓地想，张博恒不是爱他吗？"
        ],
        P127: [
            "其实不需要更多的细节和证据，潘展路已经能够感觉到当年的故事。张博恒如何从一个具体的人变成一个抽象的神？如何从硅基生物变成电子生灵？"
        ],
        P128: [
            "他从眼前的AI只言片语中已经找到了灵感，眼下就像拼拼图一样把这些碎片拼出一个具体的答案。"
        ],
        P129: [
            "他看见一个自己持枪指着另一个自己。"
        ],
        P130: [
            "其中小一点的那个很好奇：“你自杀死不掉，要来杀我？”"
        ],
        P131: [
            "“因为没有时间了。”大潘展乐摇了摇头，他做出要开枪的动作，“和你，或者说和我在一起对张博恒不好，为了阻止这个错误，我回到过去杀死十年前的自己。"
        ],
        SD001: [
            "因您的权限过低，目前此数据为一次性数据，阅后即焚，请确定是否继续阅读，本次阅读记忆余额不足5分钟。"
        ],
        P132: [
            "他看见黑云把整片天空压得很低，张博恒看着窗外的大雨：“不是算了今天宜出行吗，怎么这么大的雨？船还能开吗？”"
        ],
        P133: [
            "潘展乐拿了雨衣递给张博恒说：“我们走。”"
        ],
        P134: [
            "他们住的酒店就在海边，张博恒震惊地说：“什么船这么大雨还出海？乐乐，我们这个时候跑出去会被怀疑是神经病吧！”"
        ],
        P135: [
            "但是他一边这样说，一边穿好雨衣，提上行李，和潘展乐一起走出门。"
        ],
        P136: [
            "看到他们要出门，酒店的前台震惊说：“两位先生这么大雨也要出门吗？”"
        ],
        P137: [
            "潘展乐推开酒店的门，喧嚣的雨声一下子布满整个酒店大堂，他回过头，他的爱人就跟在他的身后。"
        ],
        P138: [
            "他于是对着空气，说不上来是对谁：“雨夜宜行船。”"
        ],
        SD002: [
            "因您的权限过低，目前此数据为一次性数据，阅后即焚，请确定是否继续阅读，本次阅读记忆余额不足5分钟。"
        ],
        P335: [
            "他看见一个长得很像张博恒的野人摘掉了自己的假发，露出张博恒的脸。张博恒震惊地对他说：“什么？你真喜欢我？”"
        ],
        P336: [
            "潘展乐看着这张熟悉的脸，结结巴巴地问他：“你，你这是什么情况？”"
        ],
        SD003: [
            "因您的权限过低，目前此数据为一次性数据，阅后即焚，请确定是否继续阅读，本次阅读记忆余额不足4分钟。"
        ],
        BT001: [
            "他看见自己对张博恒说，你喜欢我。"
        ],
        BT002: [
            "张博恒就笑了，他问所以呢？"
        ],
        BT003: [
            "只要你说，我就和女友分手，我们在一起。潘展乐回答他。"
        ],
        BT004: [
            "张博恒露出不可置信的表情，他说那天珊珊让你到泳池倒倒脑子里的水你是一点没听啊，算了，可能你脑子里有了新的水。但是潘展乐，你爱我的时候都不敢说这种话，现在把我忘了你就敢说了是吗？"
        ],
        BT005: [
            "潘展乐说我不仅敢说我还敢做，他说着拉着张博恒的领子亲了上去。"
        ],
        SD004: [
            "因您的权限过低，目前此数据为一次性数据，阅后即焚，请确定是否继续阅读，本次阅读记忆余额不足3分钟。"
        ],
        BT006: [
            "潘展乐继续看着回忆里的张博恒，他总觉得这段有些眼熟，却又怎么都想不起来与自己有什么关系。"
        ],
        BT007: [
            "他于是好奇地继续看下去，却发现张博恒脸上是他许久未见的欣喜。"
        ],
        BT008: [
            "突然之间他意识到，张博恒身边的人不是别人，正是他自己。"
        ],
        BT009: [
            "此刻，两个人正一起蹲在体总院门口，那里长期游走着几只小猫，其中有一只正乖巧地蹲在地上吃粮。"
        ],
        BT010: [
            "张博恒大概是并不讨小动物的欢心，他其实总把自己打扮得很精致，头发一丝不苟地卷在颅顶，五官也是精致漂亮的，怎么看都不应该是一副不招人喜欢的模样。"
        ],
        BT011: [
            "大概是同性相斥吧，潘展乐在旁边小声安慰他，有些猫就是会这样，不喜欢身为同类的猫，只喜欢人。"
        ],
        BT012: [
            "张博恒被他逗得笑出了声，他手里还拿着一小把猫粮，谄媚地试图把手伸到流浪猫下颌下面。"
        ],
        BT013: [
            "然而无济于事。"
        ],
        BT014: [
            "他只能求助一样地看着潘展乐，最后带着点撒娇地说：“你看嘛，小猫好像并不喜欢我。”"
        ],
        BT015: [
            "说着好像想要验证这句话一样，张博恒伸出手，探到了小猫脑袋旁边，小猫一个甩头把他的手甩开，转而却把头蹭到了潘展乐掌心里。"
        ],
        BT016: [
            "张博恒还不死心，他大概真的是蛮喜欢小猫，又贼心不死地伸出两个指尖试探，而小猫也当真不给他面子，伸出粉粉的爪子，直接一巴掌把他的手指打开。"
        ],
        BT017: [
            "潘展乐眼见张博恒又一副求助的样子，他拿人这个样子没辙，尤其这个人是隔壁高冷的体操队长。"
        ],
        BT018: [
            "他看着自己，多少燃起了潘展乐一点对大哥哥的保护欲，他于是拍了拍小猫的脑袋，说：“不许这么对哥哥。”"
        ],
        BT019: [
            "小猫委屈巴巴地喵呜了一声，但是这一次终究没有再一巴掌甩在张博恒手上。"
        ],
        BT020: [
            "这一下，张博恒终于如愿以偿地摸到了猫，他心满意足的把手指陷入小猫柔软的毛发里。"
        ],
        BT021: [
            "恋恋不舍了好一会儿他才站起来，抬眼对潘展乐说道：“你刚才说我像小猫？”"
        ],
        BT022: [
            "他这样子看人格外没有攻击性，潘展乐不知道自己当时为何红了脸颊，只是此时此刻又一次觉得脸发烫。"
        ],
        BT023: [
            "他看着回忆里的自己揉了揉乱七八糟海草一样的头发，正要小声嘀咕什么，却是张博恒率先开口。"
        ],
        BT024: [
            "他慢悠悠地说：“小猫喜欢你哦，乐乐。”"
        ],
        BT025: [
            "彼时，两个人正因为网上疯传的拉郎CP而不得不避嫌，潘展乐想不明白，张博恒到底是以怎样的立场说出这样的话，总之肯定是给中国队加油的立场吧。"
        ],
        SD005: [
            "你可以顺从自己，继续看张博恒的记忆，但是现在看真的有意义吗？你还没有获得神的爱，如果现在继续顺着张博恒的主机偷取他的数据，一旦收到神的凝视，你可没有从头再来的机会哦～"
        ],
        BT026: [
            "潘展乐继续看了下去，这一次，他少有的看到了情绪低落的张博恒。"
        ],
        BT027: [
            "这一下，潘展乐似乎也被唤醒了什么回忆。那是在一家杂货店，那时的潘展乐已经有了一个容貌姣好的女友，两个人一同约会，去路边寻找这些廉价的亮晶晶的饰品。"
        ],
        BT028: [
            "这种小店里的东西总是有限的，值得喜欢的也是有限的，因此女孩和张博恒恰到好处地选择了同一根亮亮的吊坠。"
        ],
        BT029: [
            "张伯衡只是看了一眼，就对女孩说：“女士优先，让给你吧。”"
        ],
        BT030: [
            "看他这么说，潘展乐连忙跟着一起道谢，一边道谢，一边说道：“你也喜欢这些亮晶晶的东西呀？”"
        ],
        BT031: [
            "张博恒看他一眼，对他笑着说：“是呀，喜欢这些亮晶晶的，廉价的、亮晶晶的饰品，贵的、亮晶晶的金牌，无价的、挂着金牌的运动员。”"
        ],
        BT032: [
            "如果潘展乐能再敏锐一点就好了，可是他当时什么也没有想，只是对着张博恒亮晶晶的眼睛微笑，心想你已经有最亮闪闪的东西了呀。"
        ],
        SD006: [
            "因您的权限过低，目前此数据为一次性数据，阅后即焚，请确定是否继续阅读，本次阅读记忆余额不足2分钟。"
        ],
        BT033: [
            "潘展乐没有叫停，AI年轻人就继续一个接着一个播放着当时的回忆。"
        ],
        BT034: [
            "这一次，他难得的看到了失态的张博恒。"
        ],
        BT035: [
            "张博恒撕碎了自己的日记，一片又一片的纸屑，像是夺得了冠军才下的金雨，可是这不是比赛，这段感情里他也没有赢。"
        ],
        BT036: [
            "欢喜可以伪装，体面源于克制，然而，愤怒却是最真实的情感。潘展乐意识到，这是一段厚重的感情。"
        ],
        BT037: [
            "最后，张博恒放下那些本子的碎片，很平静地说道：“我要忘了他，至少是现在，比赛才是第一位的。”"
        ],
        BT038: [
            "他说着缓缓闭上了眼睛，有什么情绪好像顺着他被遮盖起的亮晶晶的眼睛暗潮涌动。"
        ],
        P396: [
            "画面再次流转的时候，张博恒已经带着沉甸甸的荣誉躺在了床上，爱他的、崇拜他的人那样多，他们一段一段提取张博恒的记忆，再把它们投放到数据分析处理器中。"
        ],
        P397: [
            "用这种方式，他们一步步合成了一个赛博张博恒，而张博恒也终于在调试中越来越满意：“这样就对啦，之后我就用这个方式，永远活在大家心中。”"
        ],
        P398: [
            "但是过了一会儿，他又说：“把那段记忆也加上吧，不喜欢他了，我也算不上完整了。”"
        ],
        P399: [
            "年轻的工程师们面面相觑，最后他们打开了张博恒的最后一段回忆，从他的记忆深处剥出一点星星点点的爱。"
        ],
        P400: [
            "老旧的记忆已经失去光泽，只有残存的来自青春的爱闪闪发光。"
        ],
        P139: [
            "就这样他第一次知道，电子神明来自于几百年前，爱他的人想要让他获得永生，所以利用他的全套信息，制作了他的AI。"
        ],
        P140: [
            "这套大模型完全运用张博恒本人的记忆，本人的思维方式，换句话说，当他产生灵智的那一刻，醒来的不是一段数据，而是获得了永生的张博恒。"
        ],
        P141: [
            "而潘展乐也第一次在恍惚间意识到自己是怎么来到这个世界的了。"
        ],
        P142: [
            "他被已经拥有赛博神力的张博恒用科技的魔法召唤过来，穿越数百年的时光和他相遇。"
        ],
        P143: [
            "他终于输入了尘封多年的存储器的密码，得以透过时间窥见神的天光。"
        ],
        P144: [
            "在\bAI\b小哥简易的分析中，他大概认为，潘展乐如果知道自己并不是自然来到这里，而是张博恒求来的缘分，就会畏惧眼前的神。"
        ],
        P145: [
            "那他就分析错了。"
        ],
        P146: [
            "“那年杏花微雨，你说你是果郡王，原来一开始就是错的。”这是甄嬛传的台词，不是潘展乐的。"
        ],
        P337: [
            "潘展乐曾经听说过一个词叫始乱终弃，他不信那一套。所以现在，他告诉自己，张博恒也好，永恒的神也好，没有谁骗了自己。他是自愿留下的，他沉浸在神越来越浓厚的爱意里，误以为自己遵从本心，却最终失去了自我。"
        ],
        FE002: [
            "[结局：在金色的花园]|||你迷失在神金色的花园中，这里的花朵看也看不完，就这样沉醉一辈子好像也是一种属于你和张博恒的幸福。",
            "[结局：在金色的花园] ||| 你迷失在神金色的花园中，这里的花朵看也看不完，就这样沉醉一辈子好像也是一种属于你和张博恒的幸福。",
            "[结局：在金色的花园] ||| 你迷失在神金色的花园中，这里的花朵看也看不完，就这样沉醉一辈子好像也是一种属于你和张博恒的幸福。"
        ],
        P147: [
            "潘展乐试图非常唯心地一次次找出张博恒爱自己的证据，他不想远离张博恒，至少对于现在的他来说，能和张博恒一起坐在神殿数据库旁处理信息就是最幸福的事情。"
        ],
        P148: [
            "可是怀疑的种子已然种下，潘展乐想起来那枚小小的芯片。"
        ],
        P149: [
            "走在街路上，他看见茫然地被芯片控制洗脑的人们。"
        ],
        P150: [
            "他们为了移植在皮肤里的芯片短暂的欢愉，容忍机械一步一步侵占他们的肉体和灵魂。"
        ],
        P151: [
            "潘展乐想起来了发小。"
        ],
        P152: [
            "他找了个机会和张博恒告假，说想去看看之前身边的朋友。"
        ],
        P153: [
            "张博恒的4D投射非常漂亮，潘展乐能摸到他尚未发力柔软的手臂。"
        ],
        P154: [
            "他听见张博恒对着他很温和地说：“好呀，你想去的地方都可以去看，没有你做不到、到不了的，对吗，乐乐？”"
        ],
        P155: [
            "潘展乐是牢牢记住了这句话的，可是他没有见到自己的朋友。"
        ],
        P156: [
            "那年轻人沉迷在芯片的把戏中，花掉了智脑里的每一分钱。"
        ],
        P157: [
            "等潘展乐不远万里地回到朋友身边时——他现在拿着神本人的手牌，可以去任何想要的地方——却发现昔日的好友变成了一台基站。"
        ],
        P158: [
            "过多的使用芯片让他把身上的每一个零件都换成了金属，以至于失去了灵魂的容身之地，最后变成了一段短小的代码，永远地运行在这个世界中。"
        ],
        P159: [
            "潘展乐离开了，他行走在机械的丛林里，想起来这个职业最早可能叫吟游诗人，在自己曾经的年代可能叫博主。"
        ],
        P160: [
            "他终于看清楚了这个世界的本质。电子神明带着他的利器统治这个时代，这是无与伦比的电子极乐。"
        ],
        P161: [
            "随着一步一步的改造，肉身逐渐消亡，精神的信号却像无线电波一样有着自己固定的波段，最后实现一种永远存活在网上。"
        ],
        P162: [
            "这或许就是赛博飞升。"
        ],
        P163: [
            "第一次明白这个真相的时候潘展乐哭了一个晚上，他反复回忆这些片段，终于理解了电子生命对碳基生命简单的自上而下的统治。"
        ],
        P164: [
            "原来一切不过是为了制造出一批愚昧而顺从的民众，如螺丝钉一般投入到整个世界的运转中。"
        ],
        P165: [
            "在此之前，潘展乐刚刚搞明白张博恒成神的原因，他因为互联网上人们的爱而获得了一个在互联网永生成为电子神明的机会，那么自己呢？"
        ],
        P166: [
            "等待着他的赛博飞升又会是怎样的原因？"
        ],
        P167: [
            "潘展乐抬起头，他觉得眼前出现了一块巨大的电子屏，电子屏上的字瞬息万变，最后定格在了“配平”两个字。"
        ],
        P168: [
            "帮助你实现飞升的是：配平之神。你和张博恒是一对赛博CP，虽然你不认识他，他不认识你，你不爱他，他不爱你，但是配平之神说你们两个就是命之星，是天作之合。"
        ],
        P169: [
            "潘展乐茫然的看着自己，因为配平之神的神力而拥有了赛博飞升的机会，就好像张博恒因为互联网上人们的爱意成神一样，现在他也有了和张伯衡成神同样的方式，只不过用来鉴定他的神力强弱。"
        ],
        FE003: [
            "[结局：同人女の愤怒] ||| 大逆不道啊！吃饭的时候看看组名，你这么叛逆，你自己知道吗？"
        ],
        TE005: [
            "[结局：新神降临之日] ||| 一米九二的身高加上天赋秉义的大包，不选潘展乐做矿工之巅，这真的合理吗？ ||| 潘展乐第一次感觉到自己作为赛博生命存在的特别之处，他的头顶好像出现了一截蓝条，象征的意义是他的神力。 ||| 在他旁边出现了一张实时柱状图，在运动比赛的时候，你可以通过这张图看出来，你与自己对手的差距，而现在这张图上显示的是他与张博恒的神力。 ||| 伴随着矿工之巅投票的继续，潘展乐眼睁睁的看着自己的神力逐步跃升，一点一点超过了赛博神明张博恒。 ||| 这简直是不可思议，不过考虑到互联网本来就扑朔迷离、瞬息万变，一个庞大的数据在计算机的运算之下眨眼之间就可以完成，那么，潘展乐利用网络迅速得到反超，成为新一代的赛博神王，又有什么不可能呢？ ||| 潘展乐挺起胸膛，他觉得自己问心无愧，既然，芯片遵循的也是弱肉强食的道理，那就没有理由他不能利用达尔文法则获取自己想要的战利品。 ||| 适者生存。张博恒想要生存下来，必须适的者就是他潘展乐。 ||| 眼下他要钦点张博恒成为自己的伴侣，作为他的神后。 ||| 他知道张博恒正在反抗，但是那又怎样？ ||| 眼下，他已拥有了言出法随的能力！ ||| 潘展乐使用了\bh\b文攻击，只要是他大脑中幻想的剧情，就都会变成真的，不论他对张博恒抱有怎样肮脏的、不切实际的、淫靡的幻想，都将在下一刻发生在他们生活的互联网上。 ||| 他看见张博恒的小腹逐渐隆起，这似乎意味着一个赛博生命之间诞生的新生命。 ||| 这太好了，他牵着张博恒的手，两个人一起端坐在整个赛博世界的最巅峰，他宣布将制作勋章，愿意主动承认过去的神明已经成为自己发泄爱意的工具的人可以第一批获得。 ||| 他要求张博恒带着自己的孩子，一起为全新的信徒发放勋章，看到身边张博恒一只手轻轻护着微微隆起的小腹。 ||| 潘展乐知道新神正降临在他体内。"
        ],
        P170: [
            "不愿意是人类应有的权利，而他恰好手握着神赐予他的权力。"
        ],
        P171: [
            "他用了一年的时间整理出一批志同道合的朋友，而他自己则依然留在张博恒身边。"
        ],
        P172: [
            "电子神明从未想过怀疑他。"
        ],
        P173: [
            "很多时候，潘展乐想起来一个细节。"
        ],
        P174: [
            "那是一个下着雪的夜晚，他走了很久回到张博恒的身边。"
        ],
        P175: [
            "他的神披着一件设定为白色狐裘的数据包，安静地坐在圣诞树前等待他的归来。"
        ],
        P176: [
            "他那么安静，时间冲刷走了浮躁与好奇，因此他好像不再需要时不时的解闷，比如拿起智脑玩游戏看信息一类。"
        ],
        P177: [
            "那一刻，潘展乐前所未有地想要占有他，他控制不住自己的想法，一边谋划着正义的背叛，一边只带着爱意地想要独占自己的神明。"
        ],
        P178: [
            "他坐在张博恒身边，把他搂在怀里，这比他平日的举动更加大胆。"
        ],
        P179: [
            "张博恒果然侧目看向他。"
        ],
        P180: [
            "“我……如果你不介意，博恒，”潘展乐终于说出了那段话，“你喜欢我吧。”"
        ],
        P181: [
            "他想起来自己看过的张博恒的过往，他既然把自己从百年前拖入这个时空，大约也是带着爱。"
        ],
        P182: [
            "可是张博恒拒绝了。"
        ],
        P183: [
            "他摇了摇头，伸出手指拍了拍潘展乐的脑袋。"
        ],
        P184: [
            "他的动作非常平和，几乎带着点“仙人抚我顶，结发受长生”的慈悲。"
        ],
        P185: [
            "到底哪个才是真正的张博恒？"
        ],
        P186: [
            "把他抱在怀里温和如同姐姐一样的张博恒，慈悲的电子神明的张博恒，意气风发的运动员的张博恒，让他看不懂的拒绝他的张博恒。"
        ],
        P187: [
            "被拒绝的潘展乐坐在那里，好一会儿他才想起来，自己应该恨张博恒的。"
        ],
        P188: [
            "做了几百的的数字生命，他心里的天平一点点从人类的血肉歪向现在的科技。"
        ],
        P189: [
            "潘展乐一直以来都更喜欢简单的生活，他喜欢在水里只与自己比较的征服感。"
        ],
        P190: [
            "可是现在他不得不变了。"
        ],
        P191: [
            "当他带着所有的人类，冲进张博恒的神殿时，他看见张博恒侧过头，对他微笑了一下：“哥哥，你想要什么？”"
        ],
        P192: [
            "潘展乐的手里是数据的长剑，他遥遥指向张博恒的方向说：“我想要你。”"
        ],
        P193: [
            "不需要张博恒走下神坛，他自可以走上去，揭开一切数据的伪装，扼住张博恒的灵魂。"
        ],
        P194: [
            "他在电子神明统治百年的神位前，把属于人类的器官插入了神的身体里。"
        ],
        P195: [
            "属于赛博教会几百年的新时代数据达尔文注意这一刻终于到达了顶点，他听见了张博恒的声音，混合着求饶、喘息、呻吟、尖叫。"
        ],
        P196: [
            "他让他的神高潮了吗？"
        ],
        P197: [
            "这都不重要了，他能感觉到自己第二次抵达了张博恒的最深处。"
        ],
        ET004: [
            "第一次是他看到张博恒真心的时候。"
        ],
        TE001: [
            "[结局：剖腹取胎]  ||| 现在潘展乐第一次拉住了张博恒的手，他想起来自己曾经看到过切断高级人工智能思维的方式。 ||| 现在他从张博恒身后打开了基站，挖出了他的存储。 ||| 电池液顺着他的身体淅淅沥沥地流淌到了地上，潘展乐握住那片小小的内存卡，他想，原来在这片时空上驰骋了那么久的神明，只要一只手就可以握得过来。 ||| 张博恒面对着他，突然微笑了一下，他对潘展乐说：“我爱你。” ||| 潘展乐回给他一个微笑：“我知道。” ||| 两个人之间的空气变得非常静谧，潘展乐低下头看着他，听见张博恒轻声对他倾诉：“我也很爱体操，可是这个时代不需要精神也不需要运动了。” ||| 他就这样闭上眼睛，等待潘展乐毁掉那张内存卡。 ||| “啪嗒。”潘展乐抱着张博恒，他想，等到手里的存储被格式化之后，他将迎来一个新的张博恒。 |||  数据的剑尖指向神的方向，你剖出了他的欲望。"
        ],
        P198: [
            "潘展乐一直以来都更喜欢简单的生活，他喜欢在水里只与自己比较的征服感。"
        ],
        P199: [
            "可是现在他不得不变了。"
        ],
        P200: [
            "当他带着所有的人类，冲进张博恒的神殿时，他看见张博恒侧过头，对他微笑了一下：“哥哥，你想要什么？”"
        ],
        TE002: [
            "[结局：偏转月亮] ||| 沉默了很久，先开口的是潘展乐，他对张博恒说：“我知道你爱我。” ||| 张博恒瘫软在地上。 ||| 发展到他这个程度的人工智能某种程度上已经有了自己的知觉，但是是否会有刚刚操劳过的疲惫潘展乐不得而知，就好像女人不知道拥有xx的感觉一样。 ||| “你都知道了。”最后张博恒很无力地说道：“我要向你道歉，或许我不真诚吧，我不想要为了表达我的感情，失去你的憧憬。” ||| 两个人都沉默了，过了好一会儿，潘展乐的声音终于响起来，他的声音响彻曾经的神殿，他宣布了神的无期徒刑。 |||  我杀死了偏向我的月亮。"
        ],
        FE004: [
            "[结局：美少女战乐]  ||| 兄弟你这结局也太假了！ ||| 你全都要！潘展乐选择成为爱与正义的化身，一抬头他发现自己的水下战备服装变成了水手服。 ||| 潘展乐低下头，看见了自己的双马尾。 ||| 闪闪发光的，张博恒会喜欢吧？ ||| 想什么呢，爱与正义总是难以同行，你和你的所爱都非善类哦。"
        ],
        P201: [
            "第一次替换掉一部分的自己，是潘展乐用机械皮肤替换掉了一小块死皮。"
        ],
        P202: [
            "在那小小的由无数线路编织成的电子皮肤覆盖在伤口上时，首先感觉到的是一阵辛辣的疼痛。"
        ],
        P203: [
            "潘展乐有一瞬间几乎要后悔了，可是几秒钟之后，机械皮肤背后伸出无数根探针，刺入了潘展乐的血肉，下一刻将剂量始终的麻药注入了潘展乐的血管。"
        ],
        P204: [
            "潘展乐一下子失去了对疼痛的掌握，他呆滞在那里片刻，才把芯片贴在自己手臂上。"
        ],
        P205: [
            "芯片透过机械皮肤，将一段美好得不切实际的思维注入了他的大脑。"
        ],
        P206: [
            "潘展乐神情恍惚了很久，他感觉一切都在自己面前旋转起来，如果他是真正的机械就好了，那样他就可以把这种感受定义为电脑死机或者程序的\bbug\b。"
        ],
        P207: [
            "可是偏偏他是一个人，99.99%都是人类的肌理，可是偏偏这0.01%的机械皮肤给他带来无上的快感。"
        ],
        P208: [
            "潘展乐不确定这持续了多久，他犹豫了一下，缓慢放下了芯片。"
        ],
        P209: [
            "他想这是整个机械时代最好的东西了，没有之一，发小果然没有骗自己。"
        ],
        P210: [
            "那天晚上他睡得格外沉，他觉得或许是白天他的大脑用来制造那些美好的回忆太辛苦了，所以才会如此疲惫。"
        ],
        P211: [
            "他就在这样的疲惫中做了个梦，梦里他看见了一个从未见过的陌生身影，是个身量不高的年轻男人，他看不清男人的面孔，只觉得两个人的距离好像在越来越近。"
        ],
        P212: [
            "一些最美丽也最朦胧的月光笼罩在男人的脸颊上，他对潘展乐说：“你为什么不爱我？”"
        ],
        P213: [
            "潘展乐被吓醒了，他过了好一会儿才反应过来，自己梦境的终点是男人的脸颊自月光中脱颖而出，他应该感觉到一丝美，又因为那一瞬间的接近而感觉到恐惧。"
        ],
        P214: [
            "在人类还处在不够发达的时期，潘展乐曾经看到过一些都市怪谈。"
        ],
        P215: [
            "他曾经看过其中一个故事，说的是在某城市的街头，记录者曾经看到一个身形扭曲的男人，在遥远的街头吹响笛子。"
        ],
        P216: [
            "后来他发现了笔者，便以一种扭曲而快速的方式扑过来，在离笔者几步远的地方又停下，他时而出现在身后，时而出现在身前，在笔者的惊恐中两个人一步步靠近。"
        ],
        P217: [
            "潘展乐的感觉大概如此，他一向觉得这是个浪漫的故事，因为危险所以格外浪漫。"
        ],
        P218: [
            "现在他的感觉大抵如此。"
        ],
        P219: [
            "第二天早上潘展乐醒过来的时候，觉得头晕乎乎的，稍微有点疼。"
        ],
        P220: [
            "他抬起头顺着狭小的房间看向外面，那里伫立着一座雕像。"
        ],
        P221: [
            "这雕像已经在那里很久了，是披着白色头纱的神明，通体雪白由白瓷制成，那头纱雕工及其精美，就像真的丝线编制的一样薄。"
        ],
        P222: [
            "这是这个时代为数不多与艺术而不是科技有关的东西了，潘展乐不信这位神明，他来这个时空之前甚至不会向游泳之神祈祷，更别提这位电子神明了。"
        ],
        P223: [
            "谁会向电脑冰箱洗衣机祈祷呢？"
        ],
        P224: [
            "可是眼下，看着这尊美丽的雕塑，潘展乐感觉到内心前所未有的平静。"
        ],
        P225: [
            "他站起来，在十厘米见方的小窗前看了一会儿，才转身去工作。"
        ],
        P226: [
            "他工作了一天，已经非常疲惫了，本以为自己可以直接进入丝滑的睡眠，没想到他的确睡着了，可是又做了奇怪的梦。"
        ],
        P227: [
            "梦里依然是个年轻男人，五官看不清，凭直觉，潘展乐觉得他很秀气。"
        ],
        P228: [
            "但是年轻男人就这样一步一步朝他走过来，他的周围是一片模糊的迷雾，滴答滴答的水滴声倒计时一般在潘展乐脑海中响起。"
        ],
        P229: [
            "潘展乐想要后退，可是他同样做不到。"
        ],
        P230: [
            "他想起很多传说中，被梦里的人追上就会被杀死。"
        ],
        P231: [
            "他恍惚地感觉到了这种传说般的宿命感。"
        ],
        P232: [
            "从前他天不怕地不怕，甚至产生过鬼神不过干扰梦境，不可能真的影响生活的感觉。"
        ],
        P233: [
            "直到这一刻他才发现，原本以为是避风港的睡眠时间被剥夺变成惊恐的温床是多么恐怖，如果可以他宁可这人直接和自己决斗。"
        ],
        P234: [
            "梦里的男人没有碰到他，只是很温和地问他：“你真的不爱我吗？”"
        ],
        P235: [
            "潘展乐睡得很沉，第二天早上他才惊醒。"
        ],
        P236: [
            "窗子太小，没有安置窗帘的必要。"
        ],
        P237: [
            "潘展乐一抬头，看见窗外的神像和往日一样伫立着。"
        ],
        P238: [
            "不对。"
        ],
        P239: [
            "潘展乐的心脏突然紧缩了一下，他意识到一件事情。"
        ],
        P240: [
            "原本背对着他的神像，现在不知不觉间变成了面对他。"
        ],
        P241: [
            "那神像低垂着眉眼，看不出任何的喜怒哀乐，或许神明本来就不存在这样的情绪，只有人类才有。"
        ],
        P242: [
            "但是这一刻，潘展乐只觉得清晨的空气都变得粘腻，好像梦境里滴水的声音又一次回到了他耳边。"
        ],
        P243: [
            "潘展乐站起身，他不忘和老板请了个假，站在这神像前。"
        ],
        P244: [
            "可是神像什么问题都没有啊。"
        ],
        P245: [
            "没办法，潘展乐只好又回到房间里，毕竟室外的空气每天只有两小时限免。"
        ],
        P246: [
            "或许是因为担惊受怕太耗费心神，潘展乐回到房间，躺在洗碗机留给自己不大的空间里，闭上眼睛睡着了。"
        ],
        P247: [
            "这一次的梦境比上一次的更恐怖，梦里的年轻男人终于站在了他面前，他抬起手，指尖动了动，一些白色的粉末顺着他的手臂回落到手肘上。"
        ],
        P248: [
            "那男人走到了潘展乐旁边，他伸出一只手，温柔地覆盖在潘展乐眼睛上：“别看我。”"
        ],
        P249: [
            "他说着亲吻了潘展乐。"
        ],
        P250: [
            "柔软的触感让漫长的时间转瞬即逝，潘展乐好像有一次听到滴答滴答的声音从两个人中间划过。"
        ],
        P251: [
            "如果他们一直接吻，粘腻的水声就会把他们淹没，从脚一点点升高到头顶。"
        ],
        P252: [
            "他们分开的时候，潘展乐终于可以睁开眼，他心想这一次的梦感觉也不错，却突然在耀眼的白光中看到一张微笑的面孔。"
        ],
        P253: [
            "和楼下的神像看上去一模一样。"
        ],
        P254: [
            "潘展乐又一次想要后退，但是显然这是做不到的。他看见神明一只手撩起面纱，他的五官生动得好像一个真正的人类，然而表情带着白瓷一样的僵直。"
        ],
        P255: [
            "神明俯下身，对他说：“爱我吧，崇拜我吧，你的喜怒哀乐皆是我喜欢的祭品啊！”"
        ],
        P256: [
            "潘展乐在睡梦中惊醒，他猛地起身，差点害自己摔倒。"
        ],
        P257: [
            "他一醒过来就看向窗外，那神像已经彻底转到了他的方向，好像想要潘展乐给出一个确定的答案。"
        ],
        P258: [
            "潘展乐第一次主动走进神的教会。"
        ],
        P259: [
            "他对着平日里收他每周心得的神父（的麦克风）说：“我想要见一下我们的神。”"
        ],
        P260: [
            "神父的CPU看上去已经老化了，他反应了好半天才说道：“我去传达一下。”"
        ],
        P261: [
            "过了很长时间，他才走出来，对着潘展乐说：“ 你的要求我已经传递给神了，但是他不打算见你，虽然拒绝了见面，可是神是慈悲的，他会用信息的方式把你想要的答案告诉你，回去吧，你会在你的信箱里看到你想要的一切。”"
        ],
        P262: [
            "潘展乐回去之后的第一件事情就是打开了自己的信箱，那里果然躺着一封邮件没有来信人的姓名，这封信和他平时收到的不一样，图标是一片纯净的白色，潘展乐点开看到，里面写着一些大小不一的字。"
        ],
        TT001: [
            "“我很喜欢你呀，所以你的感情我还想要更多，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，不够，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多，更多……”"
        ],
        SD007: [
            "磁盘空间不足！小游戏将无法正常运行，建议清理出足够的空间再启动，以确保存档空间。"
        ],
        P263: [
            "这些字符好像真的有了声音一样，在潘展乐的大脑里响起，他觉得自己好像被一片不一样的水包围了，那些声音在信纸上组成了一双双眼睛，随后又穿透他的二模包裹住他的大脑。"
        ],
        P264: [
            "潘展乐觉得自己的思维好像被控制住了，他不由自主的想要按照神明的说法去做，他伸手握住自己，想要让自己能够与神明更加接近。"
        ],
        P265: [
            "此时此刻，他第一次想明白了眼前的神明究竟是谁，他想起来在几百年前，他曾经侧过头去夸赞自己的同桌张博恒，那时候张博恒的耳朵红红的，脸颊也红红的，他低下眼睛去看笔记本，表情和这一刻如出一辙。"
        ],
        ET001: [
            "原来这就是神明。"
        ],
        P266: [
            "他是降生在几百年后的最后一个神明，好一个张博恒，赛场上的野心家原来对于一切都充满了欲望与探索。"
        ],
        P267: [
            "真是可恨啊，潘展乐想，他恨自己是肉体凡胎，只有手上一小片皮肤才是与神明同样的机械材质。"
        ],
        P268: [
            "这样要如何才能给张博恒很多很多的爱，很多很多的感情啊！"
        ],
        P500: [
            "这样要如何才能给张博恒很多很多的爱，很多很多的感情啊！"
        ],
        TE003: [
            "[结局：吹笛人]  ||| 没有办法，我需要更多、更多的改造！ ||| 潘展乐不满足于许多人，仅仅是把自己的身体改造成胳膊里面藏电线的形状，那样要如何才能满足自己的神呢？ ||| 所以他走出房间买了空间最大的移动存储器，当他回到房间时，他拿起旁边的小刀，对准梦境里神明，想要与他连接的地方。 ||| 随后他无师自通，就好像任何一个最高明的赛博医生一样，将存储器连接在了自己身上，这之后，他自然而然地可以将内心一切污秽的想象，顺着身下的存储器传递到神的主机里。 ||| 他绝不会再让张博恒觉得不够，他此刻已经听到了存储器内存已满的提示音，（他以为自己可以用同样的水声覆盖神明的世界，却只是填满了张博恒的内存。）"
        ],
        TE004: [
            "[结局：欲望机器] ||| 就在潘展乐即将被过量的数据、信息和声音吞没时，突然一道白光顺着网络照进了潘展乐的思维。||| 是那台赛博洗碗机！||| 或许是因为曾经受到潘展乐友善的对待，能够清理附近互联网上内容的洗碗机，现在也正尽职尽责地清理着潘展乐的大脑。 ||| 被过量信息冲刷后的无力与恍惚逐渐清退，取而代之的是一种清晨换上新内裤的清爽与喜悦。 ||| 潘展乐对他的洗碗机室友说：“谢谢你。”||| 可是这一刻，他也无比清晰地直视了自己的欲望。 ||| 他想起来几百年前，由于有着各自队伍的运营方式，加之张博恒又是个好面子的，他不愿意在人们的口吻中成为被男人压住的那个。 ||| 在那次原本脸红而心跳的同桌时期曾经种下的小小的暧昧的种子，在几百年前从未生根发芽。||| 他们各自被记载，在游泳与体操的史册上，却从未真正并肩站在一起。||| 可是想着眼下与张博恒有着一模一样长相的神明，他清晰地感觉到两处脉搏跳动着他的胸口和人中。||| 如果张博恒想，他为什么不给呢？ ||| 潘展乐谢过了自己的洗碗机室友，他神清气爽、志得意满地走在大街上，他要去见张博恒，他有太多想要给张博恒的东西了，不止是喜怒哀乐。||| 但愿那纯白的主机能够承担。||| （无需笛声，全自动上套。）"
        ],
        P269: [
            "此时此刻一个叫潘展乐的男人准备跑路。"
        ],
        P270: [
            "几分钟前，他刚刚随手敷衍了一下所谓的神明和他派来的信徒，接下来他不得不带着给自己芯片的发小，踏上一条他从未想过的征程。"
        ],
        P271: [
            "发小比潘展乐矮了整整一头，他被潘展乐领着向前走，忍不住发出感叹：“你的安稳人生终究是被我毁了。”"
        ],
        P272: [
            "潘展乐回头看了一眼发小，心想这哪来的甄嬛传剧情。"
        ],
        P273: [
            "说起来可能是自己不够聪明吧，虽然在这个时代已经活了20多年，可许多东西总是记得模模糊糊的，不是很真切。"
        ],
        P274: [
            "潘展乐很难形容自己的感受，他觉得自己不是真正的感知了一段经历，而是被迫灌输了一段记忆。"
        ],
        P275: [
            "正因如此，潘展乐对周遭的一切总比常人更好奇，从前他忙着打工，连维持生存都只是勉勉强强，更别提去探索周围的世界。而眼下同样不是想那么多的时机，他带着发小，跌跌撞撞的想要找出一条远离赛博教廷，不受电子暴君掌控的道路。"
        ],
        P276: [
            "这样的道路何其难找，在几百年前，人们如果想要逃亡，还有一头扎进森林里的选项，然而在现在这个时代，树木似乎变得不那么重要了。"
        ],
        P277: [
            "他们在一地荒芜而破乱的数据线山峰之间如同躁动的原子般游走着，找不到前进的方向。"
        ],
        P278: [
            "人类的肉体凡胎需要水和食物的滋养，而不仅仅是信息流。"
        ],
        P279: [
            "他们过了很久才找到一些过去人类文明占上风时留下的遗迹，那是一条弯曲的河流，如果是在几百年前，根本算不上什么规模。"
        ],
        P280: [
            "可是现在随着碳基人类文明的倒塌，这样短的一条河流也好像成为了人类文明的延续。"
        ],
        P281: [
            "两个人一路向前走着，突然，潘展乐听到发小再次开口道：“好想再感受一次芯片呀。”"
        ],
        P282: [
            "潘展乐瞠目结舌，他想对发小说，你难道不知道吗，就是这东西，害我们不得不逃离到这里？"
        ],
        P283: [
            "但是他还什么都没来得及说，就看见发小像哄孩子一样对他微笑了一下，他说：“骗你的，我不会再用芯片了。脱下你的鞋子吧，我们要穿过溪流了。”"
        ],
        P284: [
            "他们就这样穿越溪流，朝着未知的目的地走去，就像任何一个勇士都能得到自己的宝藏一样，他们寻找到了一片未被电子暴君侵袭的净土。"
        ],
        P285: [
            "拿出过去仅剩的积蓄，潘展乐和发小在小镇租了一间小小的房子住下。"
        ],
        P286: [
            "潘展乐去提行李，在他身后发小正不紧不慢地收拾着房间，不知为什么，此刻看着发小的背影，潘展乐总觉得有什么东西在不经意间发生了变化。"
        ],
        P287: [
            "走在路上的时候，潘展乐少有的放下了一切电子设备，远离电子的监控。他忍不住开始琢磨自己的发小。过去两个人虽然关系要好，他也认可发小，的确是个非常非常好的人，但他似乎并不像现在这样温柔，坚定，带着平和的力量。"
        ],
        P288: [
            "有一瞬间，潘展乐有些恍惚，他觉得自己的发小好像变得神秘而强大，让他燃起了对最熟悉的人探索的欲望。"
        ],
        P289: [
            "究竟是哪里出了问题，让他的发小竟有了如此的变化？"
        ],
        P290: [
            "来到这里情况似乎发生了一些变化。潘展乐还住在自己基站的小房间时，曾经幻想过自己能否再拥有一只小猫，就像summer和过过一样。"
        ],
        P291: [
            "那个时候洗碗机向他提出了想要多占一点空间的请求，当然，哪怕没有这个请求，潘展乐也没有办法在那么小的房间里养猫，毕竟给他留下的空间仅仅是住一个人就足够拥挤，如果再加一只猫，简直不敢想洗碗机的天线会变成什么形状。"
        ],
        P292: [
            "可是来到这里就不一样了，这地方信息化水平低，因此容得下人类小小的生活空间，潘展乐于是动了心思，他问发小，你想要只猫吗？"
        ],
        P293: [
            "这或许是作为人类的潘展乐在这个时代最大的愿望了，他和发小一起，准备去外面捡一只流浪猫。"
        ],
        P294: [
            "俗话说得好，哪里有人类文明，哪里就有猫。没花多少心思，潘展乐就和发小一起找到了一只奶牛猫。"
        ],
        P295: [
            "潘展乐原本的计划是仗着自己身强体健，一把就把小猫捉到怀里，可他没想到自己的发小根本做不了那个诱饵。他一靠近小猫就转身逃跑。"
        ],
        P296: [
            "没办法，潘展乐只好说道：“那我去吸引小猫吧，你来把它捉住。”"
        ],
        P297: [
            "发小应声答应了，于是潘展乐蹲在路边，对着小猫伸出一只手，小猫当即朝他的方向过来，发小眼疾手快，一把将小猫捉到潘展乐怀里。"
        ],
        P298: [
            "就这样，两个人终于有了一只猫。潘展乐抱着怀里软乎乎的小团子，心里想他终于要过上和感兴趣的人与心爱的猫一起的日子了。"
        ],
        P299: [
            "然而，越想他就越觉得不对劲。潘展乐上辈子乃是响当当的直男，这辈子虽然已经做好准备，不管是男人女人机器人，只要是个人就可以恋爱，但是发小是不一样的，谁会想和自己的发小谈恋爱呢？"
        ],
        P300: [
            "发小就像是放在家里、多年一直在用的不锈钢水杯，真的会有人想和不锈钢保温杯谈恋爱吗？至少潘展乐没那个癖好，不是因为塞不进去。"
        ],
        P301: [
            "不知道为什么，潘展乐脑子里产生了一个极其微妙的想法，但是眼下抱着猫的发小，正抬头看着他说：“乐乐你看，它打我。”"
        ],
        P302: [
            "潘展乐一下子收了心思，他完全没想过从前发小以这个角度看他，他只会觉得好笑，而现在，他几乎要生出怜爱之心来。"
        ],
        P303: [
            "他一低头，果然发小，还是不招小猫的待见，小猫抬起爪子，“啪”一巴掌打在发小的手背上，似乎是在示意发小，赶紧把它放开，它要回到心爱的人类怀里。"
        ],
        P304: [
            "潘展乐赶紧伸出手，安抚地在小猫的头顶和后背上抚摸了几下，然后说道：“乖啊，宝宝，你让哥哥也抱抱。”"
        ],
        P305: [
            "或许有的人天生就有这样的魔力，小猫竟然当真不再反抗，而是顺从地停在发小掌心，让他摸了个够。"
        ],
        P306: [
            "至此，两个人终于能把小猫一起带回家里了。潘展乐对发小笑了笑说：“等你和它熟了以后，有的是你摸他的机会。”"
        ],
        P307: [
            "发小也对他笑了笑。他悠悠地摇了摇头，说道：“不一样的乐乐，同类相斥，小猫不喜欢我的。”"
        ],
        P308: [
            "哪有人这么理直气壮的把自己比成小猫呀？潘展乐本想嘲笑发小自恋，可是看着发小的眼睛，他又突然说不出这句话了，他想不知什么时候这个人的确变了，他当真像猫一样，眼睛水汪汪的，嘴角带着狡猾的笑意。"
        ],
        P309: [
            "这不是他的发小，潘展乐想，可是要揭穿吗？在这个自己最幸福的时刻。"
        ],
        P310: [
            "他犹豫了很久，对发小的义气、对眼前人的爱惜、对幸福生活的向往揉杂在一起，最后他闭了闭眼睛，只能轻轻说出一句：“你好像有些变了。”"
        ],
        P311: [
            "他们就这样和小猫一起生活了很久，久到发小这样不受猫待见的人竟然也有了让猫陪他一起睡觉的机会。"
        ],
        P312: [
            "幸福的时光总是无话可说又转瞬即逝，潘展乐几乎已经忘记了之前被神统治的恐惧，被数据支配的无助。"
        ],
        P313: [
            "他能够清晰的感知到自己情感的变化，也能够清晰的感知到自己身边发小的变化，他知道自己离真相只隔了一层薄薄的窗户纸，只要轻轻伸出手指就能捅破它，可是真的要这么做吗？"
        ],
        P314: [
            "是的，最重要的就是爱潘哲乐没有办法否认自己的确对眼前的发小产生了异样的情愫，因此他选择保守这个秘密，不论是谁占据了我重要的人的身体，既然两个都是我爱的存在，为何非要区分出孰是孰非？"
        ],
        P315: [
            "潘展乐不了解神的威能，他只是下意识地遵从自己的内心：就算你是神，那又怎样呢？"
        ],
        P316: [
            "他选择无视自己的猜测，继续留在变了的发小的身边。"
        ],
        P317: [
            "即使他无视了神就在自己身边的问题，可没有被解决的炸弹终究要爆炸，潘展乐能够感觉到，哪怕不依赖芯片，也不依赖任何改造，他依然在潜移默化地失去自己过去的认知。"
        ],
        P318: [
            "他的意识是神明的爱河，他的躯体是承装对神明爱意的容器。"
        ],
        P319: [
            "不论神明是否认为自己的伪装天衣无缝，潘展乐都决定率先揭穿这件事。"
        ],
        P320: [
            "因此，他选择了一个风和日丽的午后，那时候他的“发小”正抱着猫坐在飘窗边。"
        ],
        P321: [
            "年轻人身体瘦削只占据了飘窗上小小的一块空间，他抬起头看向潘展乐，微笑一下，问他：“你怎么啦，乐乐？看上去好严肃，有什么事情要对我说呀。”"
        ],
        P322: [
            "这时，潘展乐才意识到说出真相根本不需要任何勇气。他看着曾经发小的眼睛，问他：“你是神么？”"
        ],
        P323: [
            "他于是看到这具属于他发小的身体，或者说曾经属于他发小的身体，在一阵电磁的光波中逐渐变得扭曲，他看见眼前的人逐渐露出一张似乎带着几分熟悉的面孔。"
        ],
        P324: [
            "年轻人的身高和他的发小差不多，头发梳的整整齐齐，五官俊秀，如果不是那半空中金色的光点和略显慈悲的气质，潘展乐根本没法认出这就是传说中的神明。"
        ],
        P325: [
            "“我叫张博恒，”这是神明对他说的第一句话，“或许你已经不记得我了，或许你从来都没有过那段与我相关的记忆，但是这都不重要了，从今以后便只有你和我两个人。”"
        ],
        P326: [
            "透过神明，或者说张博恒的眼睛，潘展乐看到了一片生机勃勃的金色。他一下子就知道神明想要做什么了，他觉得自己无论是灵魂还是肉体都好像被吸着去往一个既定的方向，那就是神明所在的地方。"
        ],
        P327: [
            "潘展乐知道眼前的神还是孱弱的，这并不是他的完整状态，而只是他留在自己重要的爱的监控对象身边的一个分身，但是那又怎样，他会反抗吗？他当然不。"
        ],
        P328: [
            "潘展乐看穿了真相，但这真相正是他留在张博恒身边的原因。"
        ],
        P329: [
            "即便眼前的是伪装，可他已逐渐认识到，这伪装是他幸福的根源，重要的不是怎样的伪装，而是这是谁的伪装，只有眼前的伪装是他想要的，因此，不管张博恒想把他带去何方，他都甘之如饴。"
        ],
        P330: [
            "降落在那片金色的时候，潘展乐清晰地意识到自己的意志即将覆灭，但他最想对张博恒说，我不是被你诱拐到这里的，我是自愿的。"
        ],
        ET002: [
            "他这样心甘情愿的走上一条迷失的道路。"
        ],
        P331: [
            "既然已经明确了自己对神明的感情，那么继续留在这个小镇又有什么意义呢？潘展乐抚摸着怀里小猫的背毛，心想自己终究还是没有对它负得起责任。"
        ],
        P332: [
            "临走的时候，他把猫交给自己在这个村里最好的朋友，过去，小猫就常常驻足在他家门口，喵喵叫想要钻进人家家里。"
        ],
        P333: [
            "现在，小猫终于将要如愿以偿，而潘展乐也要，回到神明的身边，他想神为什么要盯着他，大约是没有安全感吧，既然这样，他想要的安全感就由自己来给。"
        ]
    },
    questions: {
        Q001: {
            text: "洗碗机扑腾着两条电线，试图用卖萌的方式让潘展乐主动缩小领地。潘展乐看了这家伙一眼，知道它也就是个大型宠物，没什么威胁。",
            options: [
                { id: "O001_1", text: "答应算了，潘展乐选择溺爱洗碗机，就像溺爱自己的小猫。", next: "P008" },
                { id: "O001_2", text: "这点空间必须忘记一猫两人三餐四季的梦想，再见了三花大橘奶牛虎斑……", next: "P009" }
            ]
        },
        Q002: {
            text: "那么，要试试芯片吗？",
            options: [
                { id: "O002_1", text: "不正确，那咋了？拿来吧你！几百年前潘展乐为了破纪录的理想从未如此放纵过，现在他决定先不忍了。", next: "P201" },
                { id: "O002_2", text: "潘展乐固执地守护着他从前的骄傲，他不想要以机械的形式拥有完整的一生。", next: "P048" }
            ]
        },
        Q003: {
            text: "信徒对神应该坦诚，可惜潘展乐现在还不是。他必须做出选择，保护自己和朋友。",
            options: [
                { id: "O003_1", text: "主人，就是他，和我没关系啊！" },
                { id: "O003_2", text: "我的逃跑就是我的答案！谁知道我喜欢的人会不会驾着七色镁粉来爱我啊。", next: "P269" },
                { id: "O003_3", text: "我能扛！终究是我一个人背负所有。", next: "P062" }
            ]
        },
        Q004: {
            text: "不管神是不是该如此提问，你都要回答他。",
            options: [
                { id: "O004_1", text: "无所谓！屌才在乎……哦它确实在乎，但是那句“无所谓”已经脱口而出。", next: "P097" },
                { id: "O004_2", text: "说不想就是不想，不可以吗？", next: "P100" }
            ]
        },
        Q005: {
            text: "旁边还有人虎视眈眈，继续看当然是你的自由，不过秘密就要被所有人知道了。",
            options: [
                { id: "O005_1", text: "暂时中断，有机会自己偷着看。", next: "P125" },
                { id: "O005_2", text: "这能说吗，我想看完。", next: "P129" }
            ]
        },
        Q006: {
            text: "目前此数据为一次性数据，阅后即焚，是否继续观看？",
            options: [
                { id: "O006_1", text: "这点时间能看什么？错如果看到关键剧情没时长了可就不能再看了，先不看了。", next: "P139" },
                { id: "O006_2", text: "再短的时间也能多一分了解，信他做什么，我偏要看。", next: "P132" }
            ]
        },
        Q007: {
            text: "目前此数据为一次性数据，阅后即焚，是否继续观看？",
            options: [
                { id: "O007_1", text: "这点时间能看什么？错如果看到关键剧情没时长了可就不能再看了，先不看了。", next: "P139" },
                { id: "O007_2", text: "再短的时间也能多一分了解，信他做什么，我偏要看。", next: "P335" }
            ]
        },
        Q008: {
            text: "目前此数据为一次性数据，阅后即焚，是否继续观看？",
            options: [
                { id: "O008_1", text: "这点时间能看什么？错如果看到关键剧情没时长了可就不能再看了，先不看了。", next: "P139" },
                { id: "O008_2", text: "再短的时间也能多一分了解，信他做什么，我偏要看。", next: "BT001" }
            ]
        },
        Q009: {
            text: "目前此数据为一次性数据，阅后即焚，是否继续观看？",
            options: [
                { id: "O009_1", text: "这点时间能看什么？错如果看到关键剧情没时长了可就不能再看了，先不看了。", next: "P139" },
                { id: "O009_2", text: "再短的时间也能多一分了解，信他做什么，我偏要看。", next: "BT006" }
            ]
        },
        Q010: {
            text: "是否继续观看？",
            options: [
                { id: "O010_1", text: "这点时间能看什么？错如果看到关键剧情没时长了可就不能再看了，先不看了。", next: "P139" },
                { id: "O010_2", text: "再短的时间也能多一分了解，信他做什么，我偏要看。", next: "BT026" }
            ]
        },
        Q011: {
            text: "是否继续观看？",
            options: [
                { id: "O011_1", text: "这点时间能看什么？错如果看到关键剧情没时长了可就不能再看了，先不看了。", next: "P139" },
                { id: "O011_2", text: "再短的时间也能多一分了解，信他做什么，我偏要看。", next: "BT033" }
            ]
        },
        Q012: {
            text: "现在你已经知道一切的一切不过是一场骗局， 不过你比其他人幸运，你有权利选择，如何应对这场骗局？",
            options: [
                { id: "O012_1", text: "我无所谓欺骗，潘展乐想，只要他心里有我就好。", next: "P337" },
                { id: "O012_2", text: "但是这个观点显然也是错误的。", next: "P147" }
            ]
        },
        Q013: {
            text: "这是你想要的结局吗？聆听神的心愿，实现神的夙愿，血肉的苦弱是短暂的，而灵魂的飞升是永恒的，只要这个世界还有电，你们就能一起永生。",
            options: [
                { id: "O013_1", text: "潘展乐当然选择愿意，他从前是运动员，挑战的是游泳速度的极限，现在来到这个时代，自然也要挑战一下科技的极限，我能成神吗？", next: "P165" },
                { id: "O013_2", text: "可是潘展乐明白他不愿意。", next: "P170" }
            ]
        },
        Q017: {
            text: "你可以选择伸出自己的手指，在决战乐乐茶矿工之巅比赛中为你想要的人投票。",
            options: [
                { id: "O017_1", text: "我是牛嬷王我选张博恒。" },
                { id: "O017_2", text: "潘展乐！" }
            ]
        },
        Q014: {
            text: "那么自己恨他，想要的是爱还是正义？",
            options: [
                { id: "O014_1", text: "我来到这里，是为了爱；支持我来到这里，是因为爱。" },
                { id: "O014_2", text: "我带着正义来这里，找回不见了三百年的他。", next: "P198" },
                { id: "O014_3", text: "爱是我的双腿，正义是我的剑刃。" }
            ]
        },
        Q015: {
            text: "要继续使用芯片吗？",
            options: [
                { id: "O015_1", text: "一次就好，不能为快感放弃天荒地老啊！", next: "P048" },
                { id: "O015_2", text: "瞬息万变的时代，哪里有永恒？唯有珍惜当下的快感。", next: "P208" }
            ]
        },
        Q016: {
            text: "潘展乐似乎意识到了什么，但是否揭穿真相，选择权还在他的手里。",
            options: [
                { id: "O016_1", text: "没有什么是比爱更迷人的，有些时候不知道真相或许也是一种保护。", next: "P314" },
                { id: "O016_2", text: "难道知道真相的我就没有选择爱的权利了吗？", next: "P319" },
                { id: "O016_3", text: "命运是神明的omakase，我选择顺从，不是顺从神的权威，而是顺从我的爱。所以主厨，转过身去。", next: "P331" }
            ]
        }
    },
    conditionalEndings: {
        "TE001": {
            requiredChoices: ["O014_1"],
            description: "没看完回忆"
        },
        "TE003": {
            requiredChoices: ["O001_2"],
            description: "不给洗碗机腾出位置"
        },
        "TE004": {
            requiredChoices: ["O001_1"],
            description: "为洗碗机腾出位置，欲望机器"
        }
    },
    jumps: {
        "P001": "P002",
        "P002": "P003",
        "P003": "P004",
        "P004": "P005",
        "P005": "P006",
        "P006": "P007",
        "P008": "P010",
        "P009": "P010",
        "P010": "P011",
        "P011": "P012",
        "P012": "P013",
        "P013": "P014",
        "P014": "P015",
        "P015": "P016",
        "P016": "P017",
        "P017": "P018",
        "P018": "P019",
        "P019": "P020",
        "P020": "P021",
        "P021": "P022",
        "P022": "P023",
        "P023": "P024",
        "P024": "P025",
        "P025": "P026",
        "P026": "P027",
        "P027": "P028",
        "P028": "P029",
        "P029": "P030",
        "P030": "P031",
        "P031": "P032",
        "P032": "P033",
        "P033": "P034",
        "P034": "P035",
        "P035": "P036",
        "P036": "P037",
        "P037": "P038",
        "P038": "P039",
        "P039": "P040",
        "P040": "P041",
        "P041": "P042",
        "P042": "P043",
        "P043": "P044",
        "P044": "P045",
        "P045": "P046",
        "P046": "P047",
        "P048": "P049",
        "P049": "P050",
        "P050": "P051",
        "P051": "P052",
        "P052": "P053",
        "P053": "P054",
        "P054": "P055",
        "P055": "P056",
        "P056": "P057",
        "P057": "P058",
        "P058": "P059",
        "P059": "P060",
        "P060": "P061",
        "P062": "P063",
        "P063": "P064",
        "P064": "P065",
        "P065": "P066",
        "P066": "P067",
        "P067": "P068",
        "P068": "P069",
        "P069": "P070",
        "P070": "P071",
        "P071": "P072",
        "P072": "P073",
        "P073": "P074",
        "P074": "P075",
        "P075": "P076",
        "P076": "P077",
        "P077": "P078",
        "P078": "P079",
        "P079": "P080",
        "P080": "P081",
        "P081": "P082",
        "P082": "P083",
        "P083": "P084",
        "P084": "P085",
        "P085": "P086",
        "P086": "P087",
        "P087": "P088",
        "P088": "P089",
        "P089": "P090",
        "P090": "P091",
        "P091": "P092",
        "P092": "P093",
        "P093": "P094",
        "P094": "P095",
        "P095": "P096",
        "P097": "P098",
        "P098": "P099",
        "P099": "P102",
        "P100": "P101",
        "P101": "P102",
        "P102": "P103",
        "P103": "P104",
        "P104": "P105",
        "P105": "P106",
        "P106": "P107",
        "P107": "P108",
        "P108": "P109",
        "P109": "P110",
        "P110": "P111",
        "P111": "P112",
        "P112": "P113",
        "P113": "P114",
        "P114": "P115",
        "P115": "P116",
        "P116": "P117",
        "P117": "P118",
        "P118": "P119",
        "P119": "P120",
        "P120": "P121",
        "P121": "P122",
        "P122": "P123",
        "P123": "P124",
        "P125": "P126",
        "P126": "P127",
        "P127": "P128",
        "P128": "P139",
        "P129": "P130",
        "P130": "P131",
        "P131": "SD001",
        "P132": "P133",
        "P133": "P134",
        "P134": "P135",
        "P135": "P136",
        "P136": "P137",
        "P137": "P138",
        "P138": "SD002",
        "P335": "P336",
        "P336": "SD003",
        "BT001": "BT002",
        "BT002": "BT003",
        "BT003": "BT004",
        "BT004": "BT005",
        "BT005": "SD004",
        "BT006": "BT007",
        "BT007": "BT008",
        "BT008": "BT009",
        "BT009": "BT010",
        "BT010": "BT011",
        "BT011": "BT012",
        "BT012": "BT013",
        "BT013": "BT014",
        "BT014": "BT015",
        "BT015": "BT016",
        "BT016": "BT017",
        "BT017": "BT018",
        "BT018": "BT019",
        "BT019": "BT020",
        "BT020": "BT021",
        "BT021": "BT022",
        "BT022": "BT023",
        "BT023": "BT024",
        "BT024": "BT025",
        "BT025": "SD005",
        "BT026": "BT027",
        "BT027": "BT028",
        "BT028": "BT029",
        "BT029": "BT030",
        "BT030": "BT031",
        "BT031": "BT032",
        "BT032": "SD006",
        "BT033": "BT034",
        "BT034": "BT035",
        "BT035": "BT036",
        "BT036": "BT037",
        "BT037": "BT038",
        "BT038": "P396",
        "P396": "P397",
        "P397": "P398",
        "P398": "P399",
        "P399": "P400",
        "P400": "P139",
        "P139": "P140",
        "P140": "P141",
        "P141": "P142",
        "P142": "P143",
        "P143": "P144",
        "P144": "P145",
        "P145": "P146",
        "P337": "FE002",
        "P147": "P148",
        "P148": "P149",
        "P149": "P150",
        "P150": "P151",
        "P151": "P152",
        "P152": "P153",
        "P153": "P154",
        "P154": "P155",
        "P155": "P156",
        "P156": "P157",
        "P157": "P158",
        "P158": "P159",
        "P159": "P160",
        "P160": "P161",
        "P161": "P162",
        "P162": "P163",
        "P163": "P164",
        "P165": "P166",
        "P166": "P167",
        "P167": "P168",
        "P168": "P169",
        "P170": "P171",
        "P171": "P172",
        "P172": "P173",
        "P173": "P174",
        "P174": "P175",
        "P175": "P176",
        "P176": "P177",
        "P177": "P178",
        "P178": "P179",
        "P179": "P180",
        "P180": "P181",
        "P181": "P182",
        "P182": "P183",
        "P183": "P184",
        "P184": "P185",
        "P185": "P186",
        "P186": "P187",
        "P187": "P188",
        "P189": "P190",
        "P190": "P191",
        "P191": "P192",
        "P192": "P193",
        "P193": "P194",
        "P194": "P195",
        "P195": "P196",
        "P196": "P197",
        "P197": "ET004",
        "P198": "P199",
        "P199": "P200",
        "P201": "P202",
        "P202": "P203",
        "P203": "P204",
        "P204": "P205",
        "P205": "P206",
        "P206": "P207",
        "P208": "P209",
        "P209": "P210",
        "P210": "P211",
        "P211": "P212",
        "P212": "P213",
        "P213": "P214",
        "P214": "P215",
        "P215": "P216",
        "P216": "P217",
        "P217": "P218",
        "P218": "P219",
        "P219": "P220",
        "P220": "P221",
        "P221": "P222",
        "P222": "P223",
        "P223": "P224",
        "P224": "P225",
        "P225": "P226",
        "P226": "P227",
        "P227": "P228",
        "P228": "P229",
        "P229": "P230",
        "P230": "P231",
        "P231": "P232",
        "P232": "P233",
        "P233": "P234",
        "P234": "P235",
        "P235": "P236",
        "P236": "P237",
        "P237": "P238",
        "P238": "P239",
        "P239": "P240",
        "P240": "P241",
        "P241": "P242",
        "P242": "P243",
        "P243": "P244",
        "P244": "P245",
        "P245": "P246",
        "P246": "P247",
        "P247": "P248",
        "P248": "P249",
        "P249": "P250",
        "P250": "P251",
        "P251": "P252",
        "P252": "P253",
        "P253": "P254",
        "P254": "P255",
        "P255": "P256",
        "P256": "P257",
        "P257": "P258",
        "P258": "P259",
        "P259": "P260",
        "P260": "P261",
        "P261": "P262",
        "P262": "TT001",
        "TT001": "SD007",
        "SD007": "P263",
        "P263": "P264",
        "P264": "P265",
        "P265": "ET001",
        "ET001": "P266",
        "P266": "P267",
        "P269": "P270",
        "P270": "P271",
        "P271": "P272",
        "P272": "P273",
        "P273": "P274",
        "P274": "P275",
        "P275": "P276",
        "P276": "P277",
        "P277": "P278",
        "P278": "P279",
        "P279": "P280",
        "P280": "P281",
        "P281": "P282",
        "P282": "P283",
        "P283": "P284",
        "P284": "P285",
        "P285": "P286",
        "P286": "P287",
        "P287": "P288",
        "P288": "P289",
        "P289": "P290",
        "P290": "P291",
        "P291": "P292",
        "P292": "P293",
        "P293": "P294",
        "P294": "P295",
        "P295": "P296",
        "P296": "P297",
        "P297": "P298",
        "P298": "P299",
        "P299": "P300",
        "P300": "P301",
        "P301": "P302",
        "P302": "P303",
        "P303": "P304",
        "P304": "P305",
        "P305": "P306",
        "P306": "P307",
        "P307": "P308",
        "P308": "P309",
        "P309": "P310",
        "P310": "P311",
        "P311": "P312",
        "P312": "P313",
        "P314": "P315",
        "P315": "P316",
        "P316": "P317",
        "P317": "P318",
        "P319": "P320",
        "P320": "P321",
        "P321": "P322",
        "P322": "P323",
        "P323": "P324",
        "P324": "P325",
        "P325": "P326",
        "P326": "P327",
        "P327": "P328",
        "P328": "P329",
        "P329": "P330",
        "P330": "ET002",
        "P331": "P332",
        "P332": "P333",
        "P333": "P065"
    },
    questionAfter: {
        "P007": "Q001",
        "P047": "Q002",
        "P061": "Q003",
        "P096": "Q004",
        "P124": "Q005",
        "SD001": "Q006",
        "SD002": "Q007",
        "SD003": "Q008",
        "SD004": "Q009",
        "SD005": "Q010",
        "SD006": "Q011",
        "P146": "Q012",
        "P164": "Q013",
        "P169": "Q017",
        "P188": "Q014",
        "P207": "Q015",
        "P313": "Q016"
    },
    paragraphSequence: [
        "P001",
        "// 显式跳转标记(->)，自动序列已禁用",
        "// 显式跳转连接，不是顺序显示"
    ]
};
    // ---------- 游戏数据结束 ----------
    
    // 游戏状态
    let currentState = {
        currentParagraphIndex: 0,
        paragraphQueue: [], // 初始为空，由initializeParagraphQueue填充
        displayedParagraphs: [], // 记录已显示的段落ID
        isShowingOptions: false,
        playerChoices: [], // 记录玩家的选择
        items: [], // 记录玩家获得的道具
        isModalOpen: false, // 模态窗口状态
        burnTextElements: [], // 存储阅后即焚文本元素
        hasRevived: false, // 标记是否已经通过广告复活过
        revivedFromEnding: null // 记录从哪个结局复活
    };

    // DOM元素
    const storyText = document.getElementById("story-text");
    const optionsContainer = document.getElementById("options-container");
    const modalOverlay = document.getElementById("modal-overlay");
    const modalTitle = document.getElementById("modal-title");
    const modalMessage = document.getElementById("modal-message");
    const modalCloseButton = document.getElementById("modal-close");
    const restartButton = document.getElementById("restart-button");
    const loadingScreen = document.getElementById("loading-screen");

    /**
     * 显示Windows风格的模态弹窗
     * @param {string} title - 弹窗标题
     * @param {string} message - 弹窗消息内容
     * @param {string} icon - 图标类型 (warning, error, info)
     */
    function showModal(title, message, icon = "warning") {
        // 设置弹窗内容
        modalTitle.textContent = title;
        modalMessage.textContent = message;
        
        // 设置图标
        let iconChar = "&#9888;"; // 默认警告图标
        if (icon === "error") {
            iconChar = "&#10060;"; // X图标
        } else if (icon === "info") {
            iconChar = "&#8505;"; // 信息图标
        }
        document.querySelector(".modal-icon").innerHTML = iconChar;
        
        // 显示弹窗
        modalOverlay.style.display = "flex";
        currentState.isModalOpen = true;
        
        // 记录当前弹窗内容便于关闭后处理
        modalOverlay.dataset.content = message;
    }

    /**
     * 显示广告复活选项弹窗
     * @param {string} endingId - 结局ID，用于获取对应的配置
     */
    function showReviveAdOption(endingId = "FE001") {
        console.log(`显示广告复活选项，结局ID: ${endingId}`);
        
        // 获取复活配置
        const adReviveConfig = gameData.adReviveConfig && gameData.adReviveConfig[endingId];
        
        // 强制为FE001提供默认配置
        let config = adReviveConfig;
        if (endingId === "FE001" && (!adReviveConfig || !adReviveConfig.enabled)) {
            console.log("FE001结局使用默认广告复活配置");
            config = {
                enabled: true,
                targetQuestion: "Q003",
                adTitle: "情歌王企划|《穿孔》BY：开心小猪摇摇乐",
                adContent: "<p>你紧张？</p><p>没有紧张。潘展乐攥了一下裤缝线，手心里汗涔涔的。</p><p>我看你以前打过呀，这个白点应该是长死的。你这都有经验了，还紧张啥啊。</p><p>潘展乐这下没搭话。耳钉枪顶在他耳垂上，有点凉，分不太清是枪头还是耳针。他突然想起很久很久之前张博恒说过，打耳垂钉不疼是因为耳垂上没有神经，因此感知物体的能力很差，一捅就穿，颇有种任人宰割的感觉。</p><p>张博恒还说他耳垂很软。当时张博恒一边给他吹头发一边捏他耳垂，说我们乐乐怎么回事，头发这么硬，耳朵又这么软，耳朵软的人心软，以后要吃苦的。</p><p>潘展乐闭上眼睛。</p><p><strong>嗑&刺：点击下方按钮获得复活机会！</strong></p>"
            };
        } else if (!adReviveConfig || !adReviveConfig.enabled) {
            console.log(`结局 ${endingId} 未启用广告复活功能或配置不存在`);
            return;
        }
        
        const reviveModalOverlay = document.getElementById("revive-modal-overlay");
        const reviveModalClose = document.getElementById("revive-modal-close");
        const reviveYesBtn = document.getElementById("revive-yes-btn");
        const reviveNoBtn = document.getElementById("revive-no-btn");
        
        // 显示复活选项弹窗
        reviveModalOverlay.style.display = "flex";
        
        // 设置按钮事件
        reviveYesBtn.onclick = function() {
            console.log("玩家选择观看广告复活");
            reviveModalOverlay.style.display = "none";
            showAd(config, endingId);
        };
        
        reviveNoBtn.onclick = function() {
            console.log("玩家拒绝广告复活");
            reviveModalOverlay.style.display = "none";
            // 继续游戏结束流程，不做特殊处理
        };
        
        // 关闭按钮事件（效果等同于拒绝）
        reviveModalClose.onclick = function() {
            console.log("玩家关闭复活选项弹窗");
            reviveModalOverlay.style.display = "none";
            // 继续游戏结束流程，不做特殊处理
        };
    }
    
    /**
     * 显示广告弹窗
     * @param {Object} adConfig - 广告配置
     * @param {string} endingId - 结局ID
     */
    function showAd(adConfig, endingId) {
        console.log("显示广告:", adConfig);
        const adModalOverlay = document.getElementById("ad-modal-overlay");
        const adModalTitle = document.getElementById("ad-modal-title");
        const adTitle = document.getElementById("ad-title");
        const adContent = document.getElementById("ad-content");
        const adCloseBtn = document.getElementById("ad-close-btn");
        const adModalClose = document.getElementById("ad-modal-close");
        
        // 设置广告内容
        adModalTitle.textContent = "广告";
        adTitle.textContent = adConfig.adTitle || "游戏内广告";
        adContent.innerHTML = adConfig.adContent || "感谢您支持本游戏！这是一则游戏内广告，关闭后您将获得复活机会，继续您的游戏冒险！";
        
        // 显示广告弹窗
        adModalOverlay.style.display = "flex";
        
        // 获取目标问题ID
        const targetQuestion = adConfig.targetQuestion || "Q003";
        
        // 设置关闭按钮事件
        const closeAdHandler = function() {
            console.log(`玩家关闭广告，执行复活到问题 ${targetQuestion}，来源结局 ${endingId}`);
            adModalOverlay.style.display = "none";
            // 执行复活
            reviveToQuestion(targetQuestion, endingId);
        };
        
        adCloseBtn.onclick = closeAdHandler;
        adModalClose.onclick = closeAdHandler;
    }
    
    /**
     * 复活到指定问题
     * @param {string} questionId - 问题ID
     * @param {string} fromEnding - 来源结局ID
     */
    function reviveToQuestion(questionId, fromEnding = "FE001") {
        console.log(`复活到问题: ${questionId}，来源结局: ${fromEnding}`);
        
        // 检查问题是否存在
        if (gameData.questions && gameData.questions[questionId]) {
            console.log("找到目标问题，执行复活");
            
            // 清空当前队列和历史
            currentState.paragraphQueue = [];
            
            // 设置复活状态
            currentState.hasRevived = true;
            currentState.revivedFromEnding = fromEnding;
            
            // 添加特殊段落，玩家已复活
            const reviveMsg = document.createElement("p");
            reviveMsg.textContent = "【系统】通过广告复活，你获得了重新选择的机会！";
            reviveMsg.classList.add("system-dialog");
            reviveMsg.style.backgroundColor = "rgba(76, 175, 80, 0.2)";
            reviveMsg.style.borderColor = "#4CAF50";
            storyText.appendChild(reviveMsg);
            
            // 立即显示问题
            displayOptions(gameData.questions[questionId]);
        } else {
            console.error(`复活目标问题 ${questionId} 不存在！`);
            showModal("错误", `无法复活到指定问题 ${questionId}，问题不存在。`, "error");
        }
    }

    /**
     * 关闭模态弹窗
     */
    function closeModal() {
        modalOverlay.style.display = "none";
        currentState.isModalOpen = false;
        
        // 如果是系统弹窗消息，将其添加到故事文本中
        if (modalOverlay.dataset.content) {
            displayText(modalOverlay.dataset.content, "system-dialog");
            delete modalOverlay.dataset.content;
        }
    }

    // 设置关闭按钮事件
    modalCloseButton.addEventListener("click", closeModal);

    /**
     * 显示文本内容
     * @param {string} text - 要显示的文本内容
     * @param {string} className - 可选的CSS类名
     * @param {Object} options - 额外选项
     * @param {boolean} options.typing - 是否使用打字效果
     * @param {number} options.typingSpeed - 打字效果的速度(ms)
     * @param {boolean} options.burn - 是否为阅后即焚文本
     * @param {number} options.burnDelay - 阅后即焚延迟时间(ms)
     */
    function displayText(text, className = "", options = {}) {
        const p = document.createElement("p");
        p.classList.add("fade-in");
        
        if (className) {
            p.classList.add(className);
        }
        
        // 处理结局标题和内容
        if (className === "true-ending" || className === "false-ending") {
            // 检查是否有标题格式
            let titleRegex = /^\[([^\]]+)\](.*)/s;
            const titleMatch = text.match(titleRegex);
            
            if (titleMatch) {
                // 提取标题和内容
                const title = titleMatch[1].trim();
                let content = titleMatch[2].trim();
                
                // 创建标题元素
                const titleElem = document.createElement("div");
                titleElem.classList.add("ending-title");
                titleElem.textContent = title;
                p.appendChild(titleElem);
                
                // 创建正文元素
                const contentElem = document.createElement("div");
                contentElem.classList.add("ending-content");
                
                // 处理内容中的\n换行符
                content = content.replace(/\\n/g, '\n');
                
                // 处理特殊段落分隔符 |||
                content = content.replace(/\|\|\|/g, '\n');
                
                // 将换行符转换为HTML段落
                const paragraphs = content.split('\n').filter(para => para.trim() !== '');
                
                if (paragraphs.length > 0) {
                    paragraphs.forEach((para, index) => {
                        const paraElem = document.createElement("p");
                        paraElem.textContent = para.trim();
                        contentElem.appendChild(paraElem);
                        
                        // 除了最后一段，每段后添加间距
                        if (index < paragraphs.length - 1) {
                            paraElem.style.marginBottom = "0.8rem";
                        }
                    });
                } else {
                    // 如果没有段落，添加一个空段落
                    contentElem.textContent = content;
                }
                
                p.appendChild(contentElem);
            } else {
                // 没有标题格式，直接显示文本
                p.textContent = text;
            }
        } else if (options.typing) {
            p.classList.add("typing-text");
            // 添加到DOM但初始不显示文本
            p.textContent = "";
            storyText.appendChild(p);
            
            // 逐个字符添加文本
            let i = 0;
            const typingSpeed = options.typingSpeed || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--typing-speed'));
            
            function typeNextChar() {
                if (i < text.length) {
                    p.textContent += text.charAt(i);
                    i++;
                    setTimeout(typeNextChar, typingSpeed);
                } else {
                    // 完成后移除特殊样式
                    setTimeout(() => {
                        p.classList.remove("typing-text");
                    }, 1000);
                }
            }
            
            setTimeout(typeNextChar, typingSpeed);
        } else if (options.burn) {
            p.textContent = text;
            p.classList.add("burn-text");
            storyText.appendChild(p);
            
            // 将元素添加到阅后即焚元素数组
            currentState.burnTextElements.push({
                element: p,
                timestamp: Date.now()
            });
            
            // 设置焚烧延迟
            const burnDelay = options.burnDelay || 12000; // 默认12秒后焚烧（原为5秒）
            setTimeout(() => {
                p.classList.add("burned");
                
                // 生成随机字符替换文本内容（虽然不可见但为了完整性）
                const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=-";
                let scrambled = "";
                for (let i = 0; i < text.length; i++) {
                    scrambled += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                p.dataset.originalText = p.textContent;
                p.dataset.scrambledText = scrambled;
            }, burnDelay);
        } else {
            // 处理普通段落中的|||标记
            if (text.includes('|||')) {
                const paragraphs = text.split('|||');
                // 第一段直接使用当前元素
                p.textContent = paragraphs[0].trim();
                
                // 后续段落创建新元素
                for (let i = 1; i < paragraphs.length; i++) {
                    if (paragraphs[i].trim()) {
                        const newP = document.createElement("p");
                        newP.classList.add("fade-in");
                        if (className) {
                            newP.classList.add(className);
                        }
                        newP.textContent = paragraphs[i].trim();
                        storyText.appendChild(newP);
                    }
                }
            } else {
                // 没有|||标记的普通段落
                p.textContent = text;
            }
        }
        
        // 添加到DOM
        storyText.appendChild(p);
        
        storyText.scrollTop = storyText.scrollHeight;
        return p;
    }

    /**
     * 显示选项
     * @param {Object} question - 问题对象
     */
    function displayOptions(question) {
        console.log("显示选项:", question);
        
        optionsContainer.innerHTML = "";
        currentState.isShowingOptions = true;
        
        // 在故事文本区域显示问题
        displayText(question.text, "question-text");
        
        question.options.forEach(option => {
            // 特殊处理O014_1选项
            if (option.id === "O014_1") {
                console.log("特殊处理显示O014_1选项，确保它需要key001道具并跳转到P189");
                
                // 确保有道具需求
                if (!option.requireItem) {
                    option.requireItem = {
                        id: "key001",
                        failMessage: "感受不到爱意的人也无法释放爱，你的爱是无根之水，既然无法回忆起神明曾对你倾注的爱，又何必追求你的爱要被他注视？神明永远无法得知你的爱意，它们是寄不出去的情书。"
                    };
                }
                
                // 确保有跳转目标
                option.next = "P189";
            }
            
            const button = document.createElement("button");
            button.textContent = option.text;
            button.classList.add("option-button");
            
            // 添加选项ID作为数据属性，便于调试
            button.dataset.optionId = option.id;
            
            // 检查选项文本中是否包含[NEED:道具ID:失败信息]标记
            const needMatch = option.text.match(/\[NEED:([^:]+):([^\]]+)\]/);
            if (needMatch && !option.requireItem) {
                // 提取道具ID和失败信息
                const itemId = needMatch[1];
                const failMessage = needMatch[2];
                
                console.log(`检测到选项 ${option.id} 包含NEED标记，需要道具 ${itemId}`);
                
                // 添加道具需求
                option.requireItem = {
                    id: itemId,
                    failMessage: failMessage
                };
                
                // 从显示的文本中移除标记
                button.textContent = option.text.replace(/\[NEED:[^\]]+\]/, '').trim();
            }
            
            // 检查选项文本中是否包含[JUMP:段落ID]标记
            const jumpMatch = option.text.match(/\[JUMP:([^\]]+)\]/);
            if (jumpMatch && !option.next) {
                // 提取跳转目标
                const jumpTarget = jumpMatch[1].trim();
                
                console.log(`检测到选项 ${option.id} 包含JUMP标记，跳转到 ${jumpTarget}`);
                
                // 添加跳转目标
                option.next = jumpTarget;
                
                // 从显示的文本中移除标记
                button.textContent = button.textContent.replace(/\[JUMP:[^\]]+\]/, '').trim();
            }
            
            // 检查是否需要特定道具
            let isDisabled = false;
            if (option.requireItem) {
                const hasRequiredItem = currentState.items.some(item => item.id === option.requireItem.id);
                if (!hasRequiredItem) {
                    button.classList.add("disabled");
                    isDisabled = true;
                    
                    // 添加提示信息
                    button.title = `需要道具: ${option.requireItem.failMessage}`;
                } else {
                    console.log(`选项 ${option.id} 需要道具 ${option.requireItem.id}，玩家已拥有此道具`);
                }
            }
            
            // 根据选项是否禁用添加不同的事件处理
            if (isDisabled) {
                button.addEventListener("click", () => {
                    // 显示缺少道具的提示
                    showModal("需要道具", option.requireItem.failMessage, "error");
                });
            } else {
                button.addEventListener("click", () => handleOption(option, question.text));
            }
            
            optionsContainer.appendChild(button);
        });
        
        // 滚动到选项
        setTimeout(() => {
            optionsContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);
    }

    /**
     * 检查结局条件
     * @returns {Array} 满足条件的结局ID数组
     */
    function checkForEndingConditions() {
        if (!gameData.conditionalEndings) {
            return [];
        }
        
        const matchingEndings = [];
        
        // 遍历所有结局
        for (const endingId in gameData.conditionalEndings) {
            // 获取该结局的条件
            const conditions = gameData.conditionalEndings[endingId].requiredChoices;
            
            // 检查是否满足所有条件
            const allConditionsMet = conditions.every(condition => 
                currentState.playerChoices.includes(condition));
            
            if (allConditionsMet) {
                console.log(`满足结局 ${endingId} 的所有条件`);
                matchingEndings.push(endingId);
            }
        }
        
        return matchingEndings;
    }

    /**
     * 处理选项选择
     * @param {Object} option - 选择的选项
     * @param {string} questionText - 问题文本
     */
    function handleOption(option, questionText) {
        console.log("选择选项:", option);
        
        // 检查是否是复活后重复选择导致FE001结局的选项
        if (currentState.hasRevived && 
            currentState.revivedFromEnding === "FE001" && 
            option.id === "O003_1") {
            console.log("检测到复活后再次选择导致FE001结局的选项");
            
            // 显示特殊提示
            const noMoreReviveMsg = document.createElement("p");
            noMoreReviveMsg.textContent = "【系统】不嗑真的&刺没办法拯救你每一次，重开吧。";
            noMoreReviveMsg.classList.add("system-dialog");
            noMoreReviveMsg.style.backgroundColor = "rgba(255, 70, 70, 0.2)";
            noMoreReviveMsg.style.borderColor = "#ff4646";
            noMoreReviveMsg.style.color = "#ff7070";
            storyText.appendChild(noMoreReviveMsg);
            storyText.scrollTop = storyText.scrollHeight;
            
            // 继续正常流程，但不再提供复活
            currentState.hasRevived = false; // 重置复活状态，防止再次检测
        }
        
        // 更新游戏状态
        currentState.isShowingOptions = false;
        optionsContainer.innerHTML = "";
        
        // 显示选择的选项
        displayText(`选择：${option.text}`, "selected-option");
        
        // 记录玩家选择 - 这是结局触发的前置条件，但不立即触发结局
        currentState.playerChoices.push(option.id);
        console.log("当前已选择的选项:", currentState.playerChoices);
        
        // 清空当前段落队列，准备新的流程
        currentState.paragraphQueue = [];
        
        // 特殊处理O014_1选项
        if (option.id === "O014_1") {
            console.log("特殊处理O014_1选项，确保跳转到P189");
            
            // 强制跳转到P189
            currentState.paragraphQueue.push("P189");
            
            // 确保P189能跳转到P190
            if (!gameData.jumps) {
                gameData.jumps = {};
            }
            gameData.jumps["P189"] = "P190";
            
            // 添加P189到特殊段落列表
            if (!gameData.specialParagraphs) {
                gameData.specialParagraphs = ["P189", "P190", "P396"];
            } else if (!gameData.specialParagraphs.includes("P189")) {
                gameData.specialParagraphs.push("P189");
            }
            
            console.log("已设置O014_1选项跳转到P189，P189跳转到P190");
            
            // 立即推进故事
            setTimeout(() => advanceStory(), 100);
            return;
        }
        
        // 检查选项是否是结局触发点
        if (gameData.endingTriggers && gameData.endingTriggers[option.id]) {
            const trigger = gameData.endingTriggers[option.id];
            console.log(`检查选项 ${option.id} 的结局触发器:`, trigger);
            
            // 验证结局ID是否存在
            if (gameData.paragraphs[trigger.endingId]) {
                // 检查是否满足所有条件
                const allConditionsMet = trigger.conditions.every(condition => 
                    currentState.playerChoices.includes(condition));
                
                if (allConditionsMet) {
                    console.log(`满足结局 ${trigger.endingId} 的所有条件，触发结局`);
                    
                    // 将结局添加到队列
                    currentState.paragraphQueue.push(trigger.endingId);
                } else {
                    console.log(`不满足结局 ${trigger.endingId} 的所有条件，继续正常流程`);
                }
            } else {
                console.error(`选项触发的结局ID不存在: ${trigger.endingId}`);
            }
        } 
        // 处理选项指向的下一个段落
        else if (option.next) {
            console.log("选项指向下一段落:", option.next);
            
            // 特殊处理：如果下一个段落是P189
            if (option.next === "P189") {
                console.log("检测到选项跳转到P189，确保P189和后续P190都正确加载");
                
                // 确保P189存在
                if (!gameData.paragraphs["P189"]) {
                    console.log("手动添加P189段落");
                    gameData.paragraphs["P189"] = [
                        "潘展乐一直以来都更喜欢简单的生活，他喜欢在水里只与自己比较的征服感。"
                    ];
                }
                
                // 确保P189到P190的跳转存在
                if (!gameData.jumps) {
                    gameData.jumps = {};
                }
                gameData.jumps["P189"] = "P190";
                
                // 将P189添加到队列
                currentState.paragraphQueue.push(option.next);
            } else {
                // 普通段落处理
                currentState.paragraphQueue.push(option.next);
            }
        } else if (option.jumpTo) {
            console.log("选项指向跳转目标:", option.jumpTo);
            
            // 将跳转目标添加到队列
            currentState.paragraphQueue.push(option.jumpTo);
        } else {
            console.log("选项没有指定下一个段落，查找问题后的段落");
            
            // 如果选项没有指定下一个段落，尝试查找问题ID后面的段落
            const questionId = option.id.split('_')[0].replace('O', 'Q');
            const nextParagraphId = findNextParagraphAfterQuestion(questionId);
            
            if (nextParagraphId) {
                console.log(`找到问题 ${questionId} 后的段落: ${nextParagraphId}`);
                currentState.paragraphQueue.push(nextParagraphId);
            } else {
                console.log(`未找到问题 ${questionId} 后的段落，尝试继续默认流程`);
                
                // 尝试使用默认的下一个段落（通常是问题的序号+1）
                const qNum = parseInt(questionId.substring(1));
                const possibleNextId = `P${(qNum * 10).toString().padStart(3, '0')}`;
                
                if (gameData.paragraphs[possibleNextId]) {
                    console.log(`使用可能的下一个段落: ${possibleNextId}`);
                    currentState.paragraphQueue.push(possibleNextId);
                } else {
                    console.log("无法确定下一个段落，等待用户点击");
                }
            }
        }
        
        // 立即推进故事
        setTimeout(() => advanceStory(), 100);
    }

    /**
     * 查找问题后的下一个段落
     * @param {string} questionId - 问题ID
     * @returns {string|null} 找到的段落ID或null
     */
    function findNextParagraphAfterQuestion(questionId) {
        // 如果有明确定义的问题关联，使用它
        if (gameData.questionAfter) {
            // 查找是否有段落指向这个问题
            for (const paragraphId in gameData.questionAfter) {
                if (gameData.questionAfter[paragraphId] === questionId) {
                    // 查找该段落的下一段落
                    if (gameData.jumps && gameData.jumps[paragraphId]) {
                        return gameData.jumps[paragraphId];
                    }
                }
            }
        }
        
        // 如果没有在questionAfter中找到，尝试在段落序列中定位
        if (gameData.paragraphSequence && gameData.paragraphSequence.length > 0) {
            // 过滤出有效的段落ID
            const validSequence = gameData.paragraphSequence.filter(id => 
                typeof id === 'string' && !id.startsWith('//'));
            
            // 寻找问题所在的索引
            let questionDisplayed = false;
            let paragraphAfterQuestion = null;
            
            for (let i = 0; i < currentState.displayedParagraphs.length; i++) {
                if (currentState.displayedParagraphs[i] === questionId) {
                    questionDisplayed = true;
                } else if (questionDisplayed && 
                          currentState.displayedParagraphs[i].startsWith('P')) {
                    // 找到了问题后显示的第一个段落
                    paragraphAfterQuestion = currentState.displayedParagraphs[i];
                    break;
                }
            }
            
            if (paragraphAfterQuestion) {
                return paragraphAfterQuestion;
            }
            
            // 如果在已显示的段落中没找到，尝试在段落序列中查找
            const qIndex = validSequence.indexOf(questionId);
            if (qIndex !== -1 && qIndex < validSequence.length - 1) {
                // 在序列中找到问题，返回下一个段落
                return validSequence[qIndex + 1];
            }
        }
        
        // 未找到任何相关段落
        return null;
    }

    /**
     * 处理段落中的标记（道具标记和跳转标记）
     * @param {string} paragraphId - 段落ID
     * @param {string} content - 段落内容
     * @returns {string} 清理后的内容（去除标记）
     */
    function processParagraphMarkers(paragraphId, content) {
        console.log(`处理段落标记: ${paragraphId}`);
        let cleanContent = content;
        
        // 处理道具标记 [ITEM:itemId:itemName:itemDesc]
        const itemMatch = content.match(/\[ITEM:([^:]+):([^:]+):([^\]]+)\]/);
        if (itemMatch) {
            const itemId = itemMatch[1];
            const itemName = itemMatch[2];
            const itemDesc = itemMatch[3];
            
            console.log(`检测到道具标记: ${itemId}:${itemName}`);
            
            // 移除道具标记
            cleanContent = cleanContent.replace(/\[ITEM:[^\]]+\]/, '').trim();
            
            // 保存道具获取信息
            if (!gameData.itemGrants) {
                gameData.itemGrants = {};
            }
            gameData.itemGrants[paragraphId] = {
                id: itemId,
                name: itemName,
                description: itemDesc
            };
        }
        
        // 处理跳转标记
        // 1. 处理 -> P123 格式
        let jumpMatch = cleanContent.match(/\s*->\s*([A-Z][0-9]+)$/);
        if (jumpMatch) {
            const jumpTarget = jumpMatch[1];
            console.log(`检测到跳转标记: -> ${jumpTarget}`);
            
            // 移除跳转标记
            cleanContent = cleanContent.replace(/\s*->\s*[A-Z][0-9]+$/, '').trim();
            
            // 保存跳转信息
            if (!gameData.jumps) {
                gameData.jumps = {};
            }
            gameData.jumps[paragraphId] = jumpTarget;
        }
        // 2. 处理 [JUMP:P123] 格式
        else {
            jumpMatch = cleanContent.match(/\[JUMP:\s*([^\]]+)\]/);
            if (jumpMatch) {
                const jumpTarget = jumpMatch[1].trim();
                console.log(`检测到跳转标记: [JUMP:${jumpTarget}]`);
                
                // 移除跳转标记
                cleanContent = cleanContent.replace(/\[JUMP:\s*[^\]]+\]/, '').trim();
                
                // 保存跳转信息
                if (!gameData.jumps) {
                    gameData.jumps = {};
                }
                gameData.jumps[paragraphId] = jumpTarget;
            }
        }
        
        return cleanContent;
    }

    /**
     * 显示段落，根据段落类型应用不同的样式和处理逻辑
     * @param {string} paragraphId - 段落ID
     * @returns {boolean} 是否为需要特殊处理的段落类型
     */
    function displayParagraphByType(paragraphId) {
        const paragraphs = gameData.paragraphs[paragraphId];
        
        if (!paragraphs) {
            console.error(`Paragraph ID ${paragraphId} not found!`);
            return false;
        }
        
        // 获取当前段落内容 - 修改：始终使用索引0
        const paragraphContent = paragraphs[0];
        if (!paragraphContent) {
            console.error(`段落内容未找到: ${paragraphId}[0]`);
            return false;
        }
        
        console.log(`显示段落: ${paragraphId}, 内容: ${paragraphContent.substring(0, 30)}...`);
        
        // 首先检查是否是特殊处理的段落
        if (paragraphId === "P189" || paragraphId === "P190" || paragraphId === "P396") {
            console.log(`特殊处理段落: ${paragraphId}`);
            
            // 使用processParagraphMarkers处理标记
            let cleanContent = processParagraphMarkers(paragraphId, paragraphContent);
            
            // 显示清理后的内容
            displayText(cleanContent);
            
            // 立即处理道具获取和跳转
            console.log(`强制处理段落 ${paragraphId} 的道具和跳转`);
            
            // 立即添加道具
            if (gameData.itemGrants && gameData.itemGrants[paragraphId]) {
                const item = gameData.itemGrants[paragraphId];
                console.log(`立即为段落 ${paragraphId} 添加道具: ${item.id}:${item.name}`);
                addItem(item.id, item.name, item.description);
            }
            
            // 直接设置跳转目标
            if (gameData.jumps && gameData.jumps[paragraphId]) {
                const jumpTarget = gameData.jumps[paragraphId];
                console.log(`强制 ${paragraphId} 跳转到: ${jumpTarget} (直接方式)`);
                
                // 清空当前队列，设置新目标
                currentState.paragraphQueue = [jumpTarget];
                
                // 立即推进故事
                setTimeout(() => {
                    console.log(`从段落 ${paragraphId} 立即跳转到 ${jumpTarget}`);
                    advanceStory();
                }, 100);
            }
            
            return true; // 标记为特殊段落，表示已经处理完毕
        }
        
        // 根据ID前缀判断段落类型
        const prefix = paragraphId.substring(0, 2);
        let isSpecialParagraph = false;
        
        console.log(`段落类型前缀: ${prefix}`);
        
        switch(prefix) {
            case "TE": // 真结局
                console.log(`显示真结局段落: ${paragraphId}`);
                displayText(paragraphContent, "true-ending");
                isSpecialParagraph = true;
                break;
            case "FE": // 假结局
                console.log(`显示假结局段落: ${paragraphId}`);
                displayText(paragraphContent, "false-ending");
                
                // 特殊处理结局广告复活功能
                if ((paragraphId === "FE001" || (gameData.adReviveConfig && gameData.adReviveConfig[paragraphId] && gameData.adReviveConfig[paragraphId].enabled)) && 
                    !(currentState.hasRevived && currentState.revivedFromEnding === paragraphId)) {
                    // 检查是否是复活后再次触发同一个结局
                    console.log(`触发结局 ${paragraphId}，显示广告复活选项`);
                    setTimeout(() => {
                        showReviveAdOption(paragraphId);
                    }, 1000);
                } else if (currentState.hasRevived && currentState.revivedFromEnding === paragraphId) {
                    console.log(`已从结局 ${paragraphId} 复活过，不再显示广告复活选项`);
                }
                
                isSpecialParagraph = true;
                break;
            case "SD": // 系统弹窗
                console.log(`显示系统弹窗段落: ${paragraphId}`);
                // 使用Windows风格弹窗而不是直接显示
                showModal("系统提示", paragraphContent, "warning");
                isSpecialParagraph = true;
                break;
            case "ET": // 强调文本
                console.log(`显示强调文本段落: ${paragraphId}, 内容: ${paragraphContent}`);
                displayText(paragraphContent, "emphasis-text");
                isSpecialParagraph = true;
                break;
            case "TT": // 打字效果
                console.log(`显示打字效果段落: ${paragraphId}`);
                displayText(paragraphContent, "", { typing: true, typingSpeed: 50 });
                isSpecialParagraph = true;
                break;
            case "BT": // 阅后即焚
                console.log(`显示阅后即焚段落: ${paragraphId}`);
                // 根据文本长度计算合适的延迟时间 (每个字符大约需要80毫秒阅读)
                const textLength = paragraphContent.length;
                const customBurnDelay = Math.max(12000, textLength * 80); // 最少12秒，每字符80毫秒
                console.log(`阅后即焚段落长度: ${textLength}，设置延迟: ${customBurnDelay}毫秒`);
                
                // 创建并显示阅后即焚文本
                const burnTextElement = displayText(paragraphContent, "burn-text", { burn: true, burnDelay: customBurnDelay });
                isSpecialParagraph = true;
                // 段落处理已在displayText中完成
                break;
            default: // 普通段落
                console.log(`显示普通段落: ${paragraphId}`);
                
                // 检查段落是否包含条件跳转标记 [CONDITIONAL_JUMP:条件1:目标1,条件2:目标2,默认目标]
                let cleanContent = paragraphContent;
                let conditionalJumpMatch = paragraphContent.match(/\[CONDITIONAL_JUMP:([^\]]+)\]/);
                
                if (conditionalJumpMatch) {
                    const jumpData = conditionalJumpMatch[1];
                    console.log(`检测到条件跳转标记: ${jumpData}`);
                    console.log('条件跳转格式: [CONDITIONAL_JUMP:条件1:目标1,条件2:目标2,默认目标]');
                    console.log('- 条件是之前选择的选项ID，例如O001_1');
                    console.log('- 目标是段落ID，例如P500');
                    console.log('- 默认目标是当所有条件都不满足时的跳转目标');
                    
                    // 解析条件跳转数据
                    const jumpConfig = parseConditionalJump(jumpData);
                    
                    // 移除标记，显示纯文本
                    cleanContent = paragraphContent.replace(/\[CONDITIONAL_JUMP:[^\]]+\]/, '').trim();
                    
                    // 如果成功解析，将跳转配置保存到gameData中
                    if (jumpConfig && jumpConfig.length > 0) {
                        if (!gameData.conditionalJumps) {
                            gameData.conditionalJumps = {};
                        }
                        gameData.conditionalJumps[paragraphId] = jumpConfig;
                        console.log(`已添加条件跳转配置到段落 ${paragraphId}:`, jumpConfig);
                        
                        // 打印当前选择记录，帮助调试
                        console.log(`当前玩家选择记录:`, currentState.playerChoices);
                        
                        // 如果该段落有P267这样的段落ID，则检查目标段落是否存在
                        jumpConfig.forEach(jump => {
                            if (jump.target && !gameData.paragraphs[jump.target]) {
                                console.error(`警告: 条件跳转目标 ${jump.target} 不存在!`);
                            }
                        });
                        
                        // 立即执行条件跳转的处理逻辑
                        // 查找匹配当前选择历史的跳转
                        let jumpTarget = null;
                        
                        // 遍历所有条件跳转规则
                        for (const jump of jumpConfig) {
                            // 如果这是默认跳转（没有条件）或者条件满足
                            if (!jump.condition || currentState.playerChoices.includes(jump.condition)) {
                                jumpTarget = jump.target;
                                console.log(`找到匹配的跳转目标: ${jumpTarget}, 条件: ${jump.condition || "默认"}`);
                                break;
                            }
                        }
                        
                        // 如果没有找到匹配的跳转目标，但有默认跳转（最后一个条目）
                        if (!jumpTarget && jumpConfig.length > 0) {
                            const defaultJump = jumpConfig[jumpConfig.length - 1];
                            if (!defaultJump.condition) {
                                jumpTarget = defaultJump.target;
                                console.log(`使用默认跳转目标: ${jumpTarget}`);
                            }
                        }
                        
                        // 如果找到跳转目标，将其添加到队列中
                        if (jumpTarget && gameData.paragraphs[jumpTarget]) {
                            console.log(`条件跳转: ${paragraphId} -> ${jumpTarget}`);
                            
                            // 将跳转目标添加到队列
                            if (!gameData.jumps) {
                                gameData.jumps = {};
                            }
                            gameData.jumps[paragraphId] = jumpTarget;
                            
                            // 重要修复：清空当前队列，然后将跳转目标添加到段落队列，确保立即跳转
                            currentState.paragraphQueue = [jumpTarget];
                            
                            // 立即推进故事
                            setTimeout(() => advanceStory(), 10);
                            
                            // 标记为特殊处理以避免重复跳转
                            return true; // 直接返回true表示已处理，避免继续显示其他内容
                        } else if (jumpTarget) {
                            console.error(`条件跳转目标不存在: ${jumpTarget}`);
                        } else {
                            console.log(`没有找到匹配的条件跳转，也没有默认跳转目标`);
                        }
                    }
                }
                // 检查是否有包含->ET001这样的格式，如果有，进行特殊处理
                else if (paragraphContent.includes("->ET")) {
                    // 分离实际内容和跳转标记
                    const parts = paragraphContent.split("->");
                    if (parts.length >= 2) {
                        const actualContent = parts[0].trim();
                        const jumpTarget = parts[1].trim();
                        
                        console.log(`检测到段落中包含强调文本跳转: ${jumpTarget}`);
                        console.log(`显示实际内容: ${actualContent}`);
                        
                        // 先显示实际内容
                        cleanContent = actualContent;
                        
                        // 检查跳转目标是否存在
                        if (gameData.paragraphs[jumpTarget]) {
                            console.log(`将段落 ${jumpTarget} 添加到队列前面`);
                            
                            // 立即显示强调文本
                            setTimeout(() => {
                                const emphasizedContent = gameData.paragraphs[jumpTarget][0];
                                displayText(emphasizedContent, "emphasis-text");
                                
                                // 检查是否有后续跳转
                                if (parts.length > 2) {
                                    const nextJump = parts[2].trim();
                                    console.log(`检测到后续跳转: ${nextJump}`);
                                    if (gameData.paragraphs[nextJump]) {
                                        currentState.paragraphQueue.unshift(nextJump);
                                    }
                                }
                            }, 100);
                            
                            return true; // 标记为特殊处理
                        }
                    }
                }
                // 使用processParagraphMarkers处理其他常规标记
                else {
                    // 处理道具和跳转标记
                    cleanContent = processParagraphMarkers(paragraphId, paragraphContent);
                }
                
                // 显示清理后的内容
                displayText(cleanContent);
                break;
        }
        
        return isSpecialParagraph;
    }
    
    /**
     * 解析条件跳转标记内容
     * 格式: 条件1:目标1,条件2:目标2,默认目标
     * @param {string} jumpData - 条件跳转数据
     * @returns {Array} 条件跳转配置数组
     */
    function parseConditionalJump(jumpData) {
        console.log(`解析条件跳转数据: ${jumpData}`);
        const result = [];
        
        // 分割不同的条件跳转
        const parts = jumpData.split(',');
        
        // 处理每个部分
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i].trim();
            
            // 检查是否为条件:目标格式
            const conditionMatch = part.match(/^([^:]+):(.+)$/);
            
            if (conditionMatch) {
                // 添加条件跳转
                result.push({
                    condition: conditionMatch[1].trim(),
                    target: conditionMatch[2].trim()
                });
            } else if (i === parts.length - 1) {
                // 如果是最后一项且没有冒号，视为默认跳转目标
                result.push({
                    target: part
                });
            } else {
                console.warn(`无法解析条件跳转项: ${part}`);
            }
        }
        
        // 如果没有添加默认跳转，而且有至少一个条件跳转，则添加第一个目标作为默认目标
        if (result.length > 0 && !result.some(item => !item.condition) && result[0].target) {
            console.log(`没有找到默认跳转目标，使用第一个目标 ${result[0].target} 作为默认目标`);
            result.push({
                target: result[0].target
            });
        }
        
        return result;
    }

    /**
     * 推进故事
     */
    function advanceStory() {
        // 如果弹窗打开或正在显示选项，不允许推进故事
        if (currentState.isModalOpen || currentState.isShowingOptions) {
            console.log("模态窗口已打开或正在显示选项，无法推进故事");
            return;
        }
        
        console.log("推进故事，当前队列:", currentState.paragraphQueue);
        
        if (currentState.paragraphQueue.length > 0) {
            const paragraphId = currentState.paragraphQueue[0];
            console.log("处理段落:", paragraphId);
            
            // 结局段落特殊处理 - 显示后立即从队列移除，防止重复显示
            if (paragraphId.startsWith("TE") || paragraphId.startsWith("FE")) {
                if (!currentState.displayedParagraphs.includes(paragraphId)) {
                    // 显示结局
                    displayParagraphByType(paragraphId);
                    currentState.paragraphQueue.shift(); // 从队列中移除
                    currentState.displayedParagraphs.push(paragraphId); // 标记为已显示
                } else {
                    // 结局已显示过，移除重复项
                    currentState.paragraphQueue.shift();
                }
                return; // 结局显示后返回，不再继续处理
            }
            
            // 处理问题
            if (paragraphId.startsWith("Q") && gameData.questions && gameData.questions[paragraphId]) {
                console.log("显示问题:", paragraphId);
                currentState.paragraphQueue.shift(); // 从队列中移除
                currentState.displayedParagraphs.push(paragraphId); // 标记为已显示
                displayOptions(gameData.questions[paragraphId]);
                return;
            }
            
            // 处理段落
            if (gameData.paragraphs && gameData.paragraphs[paragraphId]) {
                const paragraphs = gameData.paragraphs[paragraphId];
                
                if (Array.isArray(paragraphs) && paragraphs.length > 0) {
                    // 使用displayParagraphByType函数统一处理段落类型
                    const isSpecialParagraph = displayParagraphByType(paragraphId);
                    
                    // 检查是否获得道具 (对于非P190和P396的段落)
                    if (paragraphId !== "P190" && paragraphId !== "P396" && 
                        gameData.itemGrants && gameData.itemGrants[paragraphId]) {
                        const item = gameData.itemGrants[paragraphId];
                        addItem(item.id, item.name, item.description);
                    }
                    
                    // 从队列中移除并标记为已显示
                    currentState.paragraphQueue.shift();
                    
                    // 只有真正显示的段落才添加到displayedParagraphs中
                    if (!currentState.displayedParagraphs.includes(paragraphId)) {
                        currentState.displayedParagraphs.push(paragraphId);
                        console.log(`段落 ${paragraphId} 已添加到已显示列表`);
                    } else {
                        console.log(`段落 ${paragraphId} 已在已显示列表中，不重复添加`);
                    }
                    
                    // 特殊段落类型（ET, BT, SD, TT等）需要不同的处理逻辑
                    if (isSpecialParagraph) {
                        // 如果是特殊段落，直接处理跳转和结局逻辑，不等待点击
                        handleParagraphActions(paragraphId, true);
                    } else {
                        // P190和P396的处理已经在displayParagraphByType中完成
                        // 不需要在这里再进行特殊处理
                        
                        // 普通段落，按照用户期望的方式处理，等待点击
                        handleParagraphActions(paragraphId, false);
                    }
                } else {
                    console.error(`段落 ${paragraphId} 的格式不正确或为空！`);
                    currentState.paragraphQueue.shift(); // 从队列中移除无效段落
                }
            } else {
                console.error(`段落ID ${paragraphId} 不存在！`);
                currentState.paragraphQueue.shift(); // 从队列中移除不存在的段落
            }
        } else {
            console.log("段落队列为空，尝试找到下一个未显示的段落");
            
            // 特殊处理：检查最后显示的段落是否是P267
            const lastDisplayedParagraph = currentState.displayedParagraphs[currentState.displayedParagraphs.length - 1];
            if (lastDisplayedParagraph === "P267" && currentState.paragraphQueue.length === 0) {
                console.log("检测到P267段落，尝试执行条件跳转");
                console.log("当前玩家选择历史:", currentState.playerChoices);
                
                // 检查是否选择了O001_1
                const choseLeft = currentState.playerChoices.includes("O001_1");
                // 检查是否选择了O001_2
                const choseRight = currentState.playerChoices.includes("O001_2");
                
                console.log(`玩家选择了左(O001_1): ${choseLeft}`);
                console.log(`玩家选择了右(O001_2): ${choseRight}`);
                
                // 根据选择确定跳转目标
                let targetParagraph = "P268"; // 默认跳转
                
                if (choseLeft) {
                    targetParagraph = "P500";
                    console.log("基于玩家选择了(O001_1)，跳转到P500");
                } else if (choseRight) {
                    targetParagraph = "P268";
                    console.log("基于玩家选择了(O001_2)，跳转到P268");
                } else {
                    console.log("玩家没有相关选择记录，使用默认跳转到P268");
                }
                
                // 检查目标段落是否存在
                if (gameData.paragraphs[targetParagraph]) {
                    console.log(`从P267执行条件跳转到: ${targetParagraph}`);
                    
                    // 将跳转目标添加到队列
                    currentState.paragraphQueue.push(targetParagraph);
                } else {
                    console.error(`条件跳转目标不存在: ${targetParagraph}`);
                }
            }
            
            // 当段落队列为空时，尝试找到下一个未显示的段落
            if (gameData.paragraphSequence && gameData.paragraphSequence.length > 0) {
                // 过滤掉注释行
                const validSequence = gameData.paragraphSequence.filter(id => 
                    typeof id === 'string' && !id.startsWith('//'));
                
                // 查找当前显示的最后一个段落在序列中的位置
                let lastDisplayedIndex = -1;
                
                if (currentState.displayedParagraphs.length > 0) {
                    const lastDisplayed = currentState.displayedParagraphs[currentState.displayedParagraphs.length - 1];
                    lastDisplayedIndex = validSequence.indexOf(lastDisplayed);
                }
                
                // 查找下一个未显示的段落
                let nextParagraphFound = false;
                for (let i = lastDisplayedIndex + 1; i < validSequence.length; i++) {
                    const nextId = validSequence[i];
                    if (!currentState.displayedParagraphs.includes(nextId)) {
                        console.log(`找到下一个未显示的段落: ${nextId}`);
                        currentState.paragraphQueue.push(nextId);
                        nextParagraphFound = true;
                        break;
                    }
                }
                
                if (!nextParagraphFound) {
                    console.log("所有段落已显示完毕，故事结束");
                }
            } else {
                console.log("没有定义段落序列，故事结束");
            }
        }
    }
    
    /**
     * 处理段落后的各种动作（结局检查、跳转等）
     * @param {string} paragraphId - 段落ID
     * @param {boolean} processImmediately - 是否立即处理下一步（不等待用户点击）
     */
    function handleParagraphActions(paragraphId, processImmediately) {
        console.log(`处理段落动作: ${paragraphId}, 立即处理: ${processImmediately}`);
        
        // 特殊处理：如果是标记为检查结局的段落，检查结局条件
        const isEndingCheckPoint = gameData.endingCheckPoints && 
                                   gameData.endingCheckPoints.includes(paragraphId);
        
        if (isEndingCheckPoint) {
            console.log(`在段落 ${paragraphId} 后检查结局条件`);
            const matchingEndings = checkForEndingConditions();
            if (matchingEndings.length > 0) {
                console.log("触发结局:", matchingEndings);
                // 只添加第一个结局到队列前面，优先显示
                const ending = matchingEndings[0];
                // 检查结局是否已显示过
                if (!currentState.displayedParagraphs.includes(ending)) {
                    currentState.paragraphQueue.unshift(ending);
                    if (processImmediately) {
                        setTimeout(() => advanceStory(), 100);
                    }
                }
                return; // 直接返回，结局处理完毕
            }
        }
        
        // 检查是否有特定结局触发标记
        if (gameData.endingTriggers && gameData.endingTriggers[paragraphId]) {
            const trigger = gameData.endingTriggers[paragraphId];
            console.log(`检查段落 ${paragraphId} 的结局触发器:`, trigger);
            
            // 检查触发器格式是否完整
            if (!trigger.endingId || !trigger.conditions) {
                console.error(`结局触发器格式不正确:`, trigger);
                return;
            }
            
            // 验证结局ID是否存在
            if (!gameData.paragraphs[trigger.endingId]) {
                console.error(`触发器引用的结局ID不存在: ${trigger.endingId}`);
                return;
            }
            
            // 检查是否满足所有条件
            console.log(`检查结局触发条件:`, trigger.conditions);
            console.log(`当前玩家选择:`, currentState.playerChoices);
            
            const allConditionsMet = trigger.conditions.every(condition => 
                currentState.playerChoices.includes(condition));
            
            if (allConditionsMet) {
                console.log(`满足结局 ${trigger.endingId} 的所有条件，触发结局`);
                // 检查结局是否已显示过
                if (!currentState.displayedParagraphs.includes(trigger.endingId)) {
                    // 将结局添加到队列前面
                    currentState.paragraphQueue.unshift(trigger.endingId);
                    console.log(`已将结局 ${trigger.endingId} 添加到队列前面:`, currentState.paragraphQueue);
                    
                    if (processImmediately) {
                        console.log(`立即处理结局 ${trigger.endingId}`);
                        setTimeout(() => advanceStory(), 100);
                    }
                    return; // 直接返回，等待处理结局
                } else {
                    console.log(`结局 ${trigger.endingId} 已显示过，跳过`);
                }
            } else {
                console.log(`不满足结局 ${trigger.endingId} 的所有条件，继续正常流程`);
            }
        }
        
        // 处理条件跳转
        if (gameData.conditionalJumps && gameData.conditionalJumps[paragraphId]) {
            const jumps = gameData.conditionalJumps[paragraphId];
            console.log(`检查段落 ${paragraphId} 的条件跳转:`, jumps);
            
            // 查找匹配当前选择历史的跳转
            let jumpTarget = null;
            
            // 遍历所有条件跳转规则
            for (const jump of jumps) {
                // 如果这是默认跳转（没有条件）或者条件满足
                if (!jump.condition || currentState.playerChoices.includes(jump.condition)) {
                    jumpTarget = jump.target;
                    console.log(`找到匹配的跳转目标: ${jumpTarget}, 条件: ${jump.condition || "默认"}`);
                    break;
                }
            }
            
            // 如果找到跳转目标
            if (jumpTarget && gameData.paragraphs[jumpTarget]) {
                console.log(`条件跳转: ${paragraphId} -> ${jumpTarget}`);
                
                // 将跳转目标添加到队列前面
                currentState.paragraphQueue.unshift(jumpTarget);
                
                if (processImmediately) {
                    setTimeout(() => advanceStory(), 100);
                }
                return; // 直接返回，等待处理跳转
            } else if (jumpTarget) {
                console.error(`条件跳转目标不存在: ${jumpTarget}`);
            } else {
                console.log(`没有找到匹配的条件跳转`);
            }
        }
        
        // 检查段落内容中是否包含->ET跳转标记
        if (gameData.paragraphs && gameData.paragraphs[paragraphId] && 
            gameData.paragraphs[paragraphId][0].includes("->ET")) {
            
            console.log(`段落 ${paragraphId} 内容包含->ET跳转标记`);
            const content = gameData.paragraphs[paragraphId][0];
            const parts = content.split("->");
            
            if (parts.length >= 2) {
                const jumpTarget = parts[1].trim();
                console.log(`提取的跳转目标: ${jumpTarget}`);
                
                // 检查跳转目标是否存在
                if (gameData.paragraphs[jumpTarget]) {
                    console.log(`添加跳转目标 ${jumpTarget} 到队列前面`);
                    currentState.paragraphQueue.unshift(jumpTarget);
                    
                    // 检查是否有后续跳转
                    if (parts.length > 2) {
                        const nextTarget = parts[2].trim();
                        if (gameData.paragraphs[nextTarget]) {
                            console.log(`添加后续跳转目标 ${nextTarget} 到队列`);
                            currentState.paragraphQueue.splice(1, 0, nextTarget);
                        }
                    }
                    
                    if (processImmediately) {
                        setTimeout(() => advanceStory(), 100);
                    }
                    return; // 直接返回，等待处理跳转
                }
            }
        }
        
        // 检查是否有问题需要在此段落后显示
        if (gameData.questionAfter && gameData.questionAfter[paragraphId]) {
            const questionId = gameData.questionAfter[paragraphId];
            if (gameData.questions && gameData.questions[questionId]) {
                console.log(`段落 ${paragraphId} 后显示问题 ${questionId}`);
                currentState.paragraphQueue.unshift(questionId); // 将问题添加到队列最前面
                if (processImmediately) {
                    setTimeout(() => advanceStory(), 100);
                }
                return; // 直接返回，等待处理问题
            }
        }
        
        // 检查是否有跳转
        if (gameData.jumps && gameData.jumps[paragraphId]) {
            // 确保跳转目标去除可能的空格
            const jumpTarget = gameData.jumps[paragraphId].trim();
            console.log(`从 ${paragraphId} 跳转到 ${jumpTarget}`);
            currentState.paragraphQueue.unshift(jumpTarget);
            if (processImmediately) {
                setTimeout(() => advanceStory(), 100);
            }
            return; // 直接返回，等待处理跳转
        }
    }

    /**
     * 添加道具到玩家物品栏
     * @param {string} itemId - 道具ID
     * @param {string} itemName - 道具名称
     * @param {string} itemDescription - 道具描述
     */
    function addItem(itemId, itemName, itemDescription) {
        console.log(`尝试添加道具: ID=${itemId}, 名称=${itemName}`);
        
        // 检查道具是否已存在
        if (!currentState.items.some(item => item.id === itemId)) {
            console.log(`添加新道具: ${itemName}`);
            currentState.items.push({
                id: itemId,
                name: itemName,
                description: itemDescription
            });
            
            // 显示获得道具的消息（使用Windows弹窗）
            showModal("获得道具", `${itemName}：${itemDescription}`, "info");
            
            // 更新道具栏
            updateItemsDisplay();
        } else {
            console.log(`道具 ${itemName} (${itemId}) 已存在，不重复添加`);
        }
    }

    /**
     * 更新道具栏显示
     */
    function updateItemsDisplay() {
        const itemsContainer = document.getElementById("items-container");
        itemsContainer.innerHTML = "<h3>道具栏</h3>";
        
        if (currentState.items.length === 0) {
            itemsContainer.innerHTML += "<p>暂无道具</p>";
            return;
        }
        
        const itemsList = document.createElement("div");
        itemsList.style.display = "flex";
        itemsList.style.flexWrap = "wrap";
        itemsList.style.gap = "10px";
        
        currentState.items.forEach(item => {
            const itemElement = document.createElement("div");
            itemElement.classList.add("item");
            itemElement.title = item.description;
            itemElement.textContent = item.name;
            itemElement.style.padding = "5px 10px";
            itemElement.style.background = "rgba(0, 247, 255, 0.1)";
            itemElement.style.border = "1px solid var(--accent-color)";
            itemElement.style.borderRadius = "5px";
            itemElement.style.cursor = "help";
            
            itemsList.appendChild(itemElement);
        });
        
        itemsContainer.appendChild(itemsList);
    }
    
    /**
     * 重新开始游戏
     */
    function restartGame() {
        // 确认是否重新开始
        showModal("确认重启", "确定要重新开始游戏吗？所有进度将丢失。", "warning");
        
        // 替换模态框关闭按钮事件
        const oldCloseEvent = modalCloseButton.onclick;
        modalCloseButton.onclick = function() {
            modalOverlay.style.display = "none";
            currentState.isModalOpen = false;
            
            // 重置游戏状态
            currentState = {
                currentParagraphIndex: 0,
                paragraphQueue: [],
                displayedParagraphs: [],
                isShowingOptions: false,
                playerChoices: [],
                items: [],
                isModalOpen: false,
                burnTextElements: [],
                hasRevived: false,
                revivedFromEnding: null
            };
            
            // 清空故事区域
            storyText.innerHTML = "";
            optionsContainer.innerHTML = "";
            
            // 重新初始化段落队列
            initializeParagraphQueue();
            
            // 开始新游戏
            advanceStory();
            updateItemsDisplay();
            
            // 恢复原始关闭事件
            modalCloseButton.onclick = oldCloseEvent;
        };
    }
    
    // 重启按钮事件
    restartButton.addEventListener("click", restartGame);

    // 点击事件处理
    document.addEventListener("click", (e) => {
        // 如果点击的是模态窗口内部或选项按钮，不做处理
        if (e.target.closest(".modal-window") || e.target.classList.contains("option-button") || 
            e.target.id === "restart-button") {
            return;
        }
        
        // 如果弹窗打开，不推进故事
        if (!currentState.isModalOpen && !currentState.isShowingOptions) {
            // 在控制台记录当前状态，便于调试
            console.log("点击事件触发，当前状态:", JSON.stringify({
                paragraphQueue: currentState.paragraphQueue,
                displayedParagraphs: currentState.displayedParagraphs
            }));
            
            // 特殊处理：检查最后显示的段落是否是特殊段落
            const lastDisplayedParagraph = currentState.displayedParagraphs[currentState.displayedParagraphs.length - 1];
            
            // 特殊处理P189段落
            if (lastDisplayedParagraph === "P189" && currentState.paragraphQueue.length === 0) {
                console.log("检测到P189段落，强制执行跳转到P190");
                
                // 直接跳转到P190
                if (gameData.jumps && gameData.jumps["P189"]) {
                    const jumpTarget = gameData.jumps["P189"];
                    console.log(`强制P189跳转到: ${jumpTarget}`);
                    currentState.paragraphQueue.push(jumpTarget);
                } else {
                    console.log("未找到P189的跳转配置，手动添加跳转到P190");
                    currentState.paragraphQueue.push("P190");
                }
            }
            // 特殊处理P190段落
            else if (lastDisplayedParagraph === "P190" && currentState.paragraphQueue.length === 0) {
                console.log("检测到P190段落，强制执行跳转");
                
                // 手动触发道具获取
                if (gameData.itemGrants && gameData.itemGrants["P190"]) {
                    const item = gameData.itemGrants["P190"];
                    addItem(item.id, item.name, item.description);
                }
                
                // 执行跳转
                if (gameData.jumps && gameData.jumps["P190"]) {
                    const jumpTarget = gameData.jumps["P190"];
                    console.log(`强制P190跳转到: ${jumpTarget}`);
                    currentState.paragraphQueue.push(jumpTarget);
                }
            }
            // 特殊处理P396段落
            else if (lastDisplayedParagraph === "P396" && currentState.paragraphQueue.length === 0) {
                console.log("检测到P396段落，强制执行跳转");
                
                // 手动触发道具获取
                if (gameData.itemGrants && gameData.itemGrants["P396"]) {
                    const item = gameData.itemGrants["P396"];
                    addItem(item.id, item.name, item.description);
                }
                
                // 执行跳转
                if (gameData.jumps && gameData.jumps["P396"]) {
                    const jumpTarget = gameData.jumps["P396"];
                    console.log(`强制P396跳转到: ${jumpTarget}`);
                    currentState.paragraphQueue.push(jumpTarget);
                }
            }
            // 特殊处理：检查最后显示的段落是否是P267
            else if (lastDisplayedParagraph === "P267" && currentState.paragraphQueue.length === 0) {
                console.log("检测到P267段落，尝试执行条件跳转");
                
                // 检查是否有P267的条件跳转配置
                if (gameData.conditionalJumps && gameData.conditionalJumps["P267"]) {
                    const jumps = gameData.conditionalJumps["P267"];
                    console.log("P267条件跳转配置:", jumps);
                    
                    // 查找匹配当前选择历史的跳转
                    let jumpTarget = null;
                    let jumpCondition = null;
                    
                    // 遍历所有条件跳转规则
                    for (const jump of jumps) {
                        // 如果这是默认跳转（没有条件）或者条件满足
                        if (!jump.condition || currentState.playerChoices.includes(jump.condition)) {
                            jumpTarget = jump.target;
                            jumpCondition = jump.condition;
                            console.log(`找到匹配的跳转目标: ${jumpTarget}, 条件: ${jumpCondition || "默认"}`);
                            break;
                        }
                    }
                    
                    // 如果找到跳转目标
                    if (jumpTarget && gameData.paragraphs[jumpTarget]) {
                        console.log(`从P267执行条件跳转到: ${jumpTarget}, 基于条件: ${jumpCondition || "默认"}`);
                        console.log(`当前玩家选择历史: ${JSON.stringify(currentState.playerChoices)}`);
                        
                        // 将跳转目标添加到队列
                        currentState.paragraphQueue.push(jumpTarget);
                    } else if (jumpTarget) {
                        console.error(`条件跳转目标不存在: ${jumpTarget}`);
                    } else {
                        console.log(`没有找到P267的匹配跳转目标，使用默认跳转到P268`);
                        // 使用默认跳转
                        if (gameData.paragraphs["P268"]) {
                            currentState.paragraphQueue.push("P268");
                        }
                    }
                }
            }
            
            // 推进故事
            advanceStory();
        }
    });

    // 添加键盘事件监听，F10键显示调试信息
    document.addEventListener("keydown", (e) => {
        // F10键 (121) - 显示调试信息
        if (e.keyCode === 121) {
            showDebugInfo();
        }
    });
    
    /**
     * 显示调试信息
     */
    function showDebugInfo() {
        console.log("========== 游戏调试信息 ==========");
        console.log("当前队列:", currentState.paragraphQueue);
        console.log("已显示段落:", currentState.displayedParagraphs);
        console.log("玩家选择:", currentState.playerChoices);
        console.log("拥有道具:", currentState.items);
        
        if (gameData.conditionalEndings) {
            console.log("条件结局:");
            for (const endingId in gameData.conditionalEndings) {
                const ending = gameData.conditionalEndings[endingId];
                const metConditions = ending.requiredChoices.filter(choice => 
                    currentState.playerChoices.includes(choice));
                
                console.log(`  ${endingId}:`);
                console.log(`    描述: ${ending.description}`);
                console.log(`    需要选项: ${ending.requiredChoices.join(', ')}`);
                console.log(`    已满足选项: ${metConditions.join(', ')}`);
                console.log(`    进度: ${metConditions.length}/${ending.requiredChoices.length}`);
            }
        }
        
        if (gameData.endingTriggers) {
            console.log("结局触发器:");
            for (const paragraphId in gameData.endingTriggers) {
                const trigger = gameData.endingTriggers[paragraphId];
                console.log(`  ${paragraphId} -> ${trigger.endingId}`);
                console.log(`    条件: ${trigger.conditions.join(', ')}`);
            }
        }
        
        // 弹出提示
        alert("调试信息已在控制台输出。按F12键打开开发者工具查看。");
    }

    // 游戏数据预处理函数，在游戏初始化时调用
    function prepareGameData() {
        console.log("处理游戏数据...");
        console.log("游戏数据:", gameData);
        
        // 检查并输出游戏数据
        if (gameData && gameData.paragraphs) {
            console.log("段落数:", Object.keys(gameData.paragraphs).length);
            console.log("问题数:", gameData.questions ? Object.keys(gameData.questions).length : 0);
            
            // 输出跳转信息
            if (gameData.jumps) {
                console.log("跳转数:", Object.keys(gameData.jumps).length);
                console.log("跳转详情:", gameData.jumps);
            } else {
                console.warn("警告：没有定义跳转！这可能导致游戏流程不完整。");
            }
            
            // 初始化或补充结局触发器信息
            if (!gameData.endingTriggers) {
                gameData.endingTriggers = {};
            }
            
            // 添加特定选项的结局触发器（基于原始文本中的[TRIGGER_ENDING]标记）
            // 这些标记在转换过程中只清理了文本，但没有添加到触发器数据中
            // O003_1 应触发 FE001
            if (!gameData.endingTriggers["O003_1"]) {
                gameData.endingTriggers["O003_1"] = {
                    endingId: "FE001",
                    conditions: ["O003_1"]
                };
            }
            
            // 添加P200段落的结局触发器
            if (!gameData.endingTriggers["P200"]) {
                gameData.endingTriggers["P200"] = {
                    endingId: "TE002",
                    conditions: ["O014_2"]
                };
            }
            
            // 添加其他可能缺失的触发器
            // ET004段落应触发TE001
            if (!gameData.endingTriggers["ET004"]) {
                gameData.endingTriggers["ET004"] = {
                    endingId: "TE001",
                    conditions: ["O014_1"]
                };
            }
            
            // P268段落应触发TE003
            if (!gameData.endingTriggers["P268"]) {
                gameData.endingTriggers["P268"] = {
                    endingId: "TE003",
                    conditions: ["O001_2"]
                };
            }
            
            // P500段落应触发TE004
            if (!gameData.endingTriggers["P500"]) {
                gameData.endingTriggers["P500"] = {
                    endingId: "TE004",
                    conditions: ["O001_1"]
                };
            }
            
            // 检查并修复O014_1选项
            console.log("检查O014_1选项配置");
            
            // 找到O014_1选项并添加正确的跳转和道具需求
            if (gameData.questions) {
                let foundO014_1 = false;
                
                for (const questionId in gameData.questions) {
                    const question = gameData.questions[questionId];
                    if (question.options) {
                        for (let i = 0; i < question.options.length; i++) {
                            const option = question.options[i];
                            if (option.id === "O014_1") {
                                console.log("找到O014_1选项，确保它有正确的跳转和道具需求");
                                foundO014_1 = true;
                                
                                // 确保有道具需求
                                if (!option.requireItem) {
                                    option.requireItem = {
                                        id: "key001",
                                        failMessage: "感受不到爱意的人也无法释放爱，你的爱是无根之水，既然无法回忆起神明曾对你倾注的爱，又何必追求你的爱要被他注视？神明永远无法得知你的爱意，它们是寄不出去的情书。"
                                    };
                                }
                                
                                // 确保有跳转目标
                                option.next = "P189";
                                console.log("已设置O014_1选项跳转到P189");
                                
                                // 记录已更新的选项
                                console.log("更新后的O014_1选项:", option);
                            }
                        }
                    }
                }
                
                if (!foundO014_1) {
                    console.log("警告: 未找到O014_1选项");
                }
            }
            
            // 初始化条件跳转数据结构
            if (!gameData.conditionalJumps) {
                gameData.conditionalJumps = {};
            }
            
            // 添加P267段落的条件跳转
            if (!gameData.conditionalJumps["P267"]) {
                gameData.conditionalJumps["P267"] = [
                    {
                        condition: "O001_1",
                        target: "P500"
                    },
                    {
                        condition: "O001_2",
                        target: "P268"
                    },
                    {
                        target: "P268" // 默认跳转目标
                    }
                ];
                console.log("已添加P267的条件跳转配置:", gameData.conditionalJumps["P267"]);
            }
            
            // O014_3选项应触发FE004
            if (!gameData.endingTriggers["O014_3"]) {
                gameData.endingTriggers["O014_3"] = {
                    endingId: "FE004",
                    conditions: ["O014_3"]
                };
            }
            
            // P318段落应触发FE002
            if (!gameData.endingTriggers["P318"]) {
                gameData.endingTriggers["P318"] = {
                    endingId: "FE002",
                    conditions: ["O016_1"]
                };
            }
            
            // ET002段落应触发FE002
            if (!gameData.endingTriggers["ET002"]) {
                gameData.endingTriggers["ET002"] = {
                    endingId: "FE002",
                    conditions: ["O016_2"]
                };
            }
            
            // O017_1选项应触发FE003
            if (!gameData.endingTriggers["O017_1"]) {
                gameData.endingTriggers["O017_1"] = {
                    endingId: "FE003",
                    conditions: ["O017_1"]
                };
            }
            
            // O017_2选项应触发TE005
            if (!gameData.endingTriggers["O017_2"]) {
                gameData.endingTriggers["O017_2"] = {
                    endingId: "TE005",
                    conditions: ["O017_2"]
                };
            }
            
            // 调试: 输出结局触发器信息
            if (gameData.endingTriggers) {
                console.log("结局触发器数:", Object.keys(gameData.endingTriggers).length);
                console.log("结局触发器详情:", gameData.endingTriggers);
            } else {
                console.warn("警告：没有定义结局触发器！");
            }
            
            // 调试: 输出条件结局信息
            if (gameData.conditionalEndings) {
                console.log("条件结局数:", Object.keys(gameData.conditionalEndings).length);
                console.log("条件结局详情:", gameData.conditionalEndings);
            } else {
                console.warn("警告：没有定义条件结局！");
            }
            
            // 调试: 输出条件跳转信息
            if (gameData.conditionalJumps) {
                console.log("条件跳转数:", Object.keys(gameData.conditionalJumps).length);
                console.log("条件跳转详情:", gameData.conditionalJumps);
            } else {
                console.warn("警告：没有定义条件跳转！");
            }
            
            // 调试: 输出道具信息
            if (gameData.itemGrants) {
                console.log("道具获取数:", Object.keys(gameData.itemGrants).length);
                console.log("道具获取详情:", gameData.itemGrants);
            } else {
                console.warn("警告：没有定义道具获取！");
                // 初始化空的道具获取对象
                gameData.itemGrants = {};
            }
            
            // 确保jumps对象存在
            if (!gameData.jumps) {
                gameData.jumps = {};
            }
            
            // 重要：统一处理P396和P190段落的道具和跳转配置
            console.log("初始化特殊段落的道具和跳转配置");
            
            // P396段落 - 道具和跳转配置
            gameData.itemGrants["P396"] = {
                id: "key001",
                name: "来自神的爱意",
                description: "这是一个重要的密钥"
            };
            gameData.jumps["P396"] = "P397";
            console.log("已配置P396段落的道具和跳转:", gameData.itemGrants["P396"], gameData.jumps["P396"]);
            
            // P190段落 - 道具和跳转配置
            gameData.itemGrants["P190"] = {
                id: "key002",
                name: "给神明的饭撒",
                description: "这是另一个重要的密钥"
            };
            
            // 确保P190段落存在
            if (!gameData.paragraphs["P190"]) {
                console.log("手动添加P190段落");
                gameData.paragraphs["P190"] = [
                    "可是现在他不得不变了。 [ITEM:key002:给神明的饭撒:这是另一个重要的密钥]"
                ];
            }
            
            // 强制设置P190到P191的跳转
            gameData.jumps["P190"] = "P191";
            console.log("已强制配置P190段落的跳转到P191:", gameData.jumps["P190"]);
            
            // 确保P189段落存在并正确配置跳转
            if (!gameData.paragraphs["P189"]) {
                console.log("手动添加P189段落");
                gameData.paragraphs["P189"] = [
                    "潘展乐一直以来都更喜欢简单的生活，他喜欢在水里只与自己比较的征服感。"
                ];
            }
            
            // 强制设置P189到P190的跳转
            gameData.jumps["P189"] = "P190";
            console.log("已强制配置P189段落的跳转到P190:", gameData.jumps["P189"]);
            
            // 添加P189到特殊段落列表
            if (!gameData.specialParagraphs) {
                gameData.specialParagraphs = ["P189", "P190", "P396"];
            } else if (!gameData.specialParagraphs.includes("P189")) {
                gameData.specialParagraphs.push("P189");
            }
            
            // 确保P191段落存在
            if (!gameData.paragraphs["P191"]) {
                console.log("手动添加P191段落");
                gameData.paragraphs["P191"] = [
                    "用这种方式，他就获得了神明的饭撒，迈向了新的旅程。"
                ];
                
                // 添加P191到下一段落的跳转
                gameData.jumps["P191"] = "P192";
            } else {
                console.log("P191段落已存在:", gameData.paragraphs["P191"][0]);
            }
            
            // 确保P192段落存在
            if (!gameData.paragraphs["P192"] && !gameData.jumps["P191"]) {
                console.log("手动添加P192段落");
                gameData.paragraphs["P192"] = [
                    "这段旅程将带他去向新的地方。"
                ];
                
                // 默认设置P191跳转到P192
                gameData.jumps["P191"] = "P192";
            }
            
            // 添加特殊段落列表，用于特殊处理
            if (!gameData.specialParagraphs) {
                gameData.specialParagraphs = ["P190", "P396"];
            }
            
            // 确保P397段落存在
            if (!gameData.paragraphs["P397"] && gameData.paragraphs["P396"]) {
                console.log("手动添加P397段落");
                gameData.paragraphs["P397"] = [
                    "用这种方式，他们一步步合成了一个赛博张博恒，而张博恒也终于在调试中越来越满意：\"这样就对啦，之后我就用这个方式，永远活在大家心中。\""
                ];
                
                // 添加P397到P398的跳转
                gameData.jumps["P397"] = "P398";
            }
            
            // 确保P398段落存在
            if (!gameData.paragraphs["P398"] && gameData.paragraphs["P397"]) {
                console.log("手动添加P398段落");
                gameData.paragraphs["P398"] = [
                    "但是过了一会儿，他又说：\"把那段记忆也加上吧，不喜欢他了，我也算不上完整了。\""
                ];
                
                // 添加P398到P399的跳转
                gameData.jumps["P398"] = "P399";
            }
            
            // 添加一个演示用的道具依赖问题
            if (!gameData.paragraphs["P399"]) {
                gameData.paragraphs["P399"] = [
                    "年轻的工程师们面面相觑，最终他们决定询问你的意见。"
                ];
                
                // 让P399后显示问题Q020
                if (!gameData.questionAfter) {
                    gameData.questionAfter = {};
                }
                gameData.questionAfter["P399"] = "Q020";
                
                // 添加问题Q020
                if (!gameData.questions) {
                    gameData.questions = {};
                }
                gameData.questions["Q020"] = {
                    text: "工程师询问你是否要还原张博恒所有的记忆？",
                    options: [
                        {
                            id: "O020_1",
                            text: "使用神的爱意密钥，还原所有记忆",
                            requireItem: {
                                id: "key001",
                                failMessage: "你需要拥有来自神的爱意才能执行此操作"
                            },
                            next: "P400"
                        },
                        {
                            id: "O020_2",
                            text: "拒绝，记忆有时是一种负担",
                            next: "P401"
                        }
                    ]
                };
                
                // 添加选项结果段落
                gameData.paragraphs["P400"] = [
                    "你使用了神的爱意密钥，工程师们成功还原了张博恒的全部记忆。现在的他，是完整的他。"
                ];
                
                gameData.paragraphs["P401"] = [
                    "你拒绝了请求。有些记忆，或许永远尘封才是最好的结局。"
                ];
            }
            
            // 初始化段落队列
            initializeParagraphQueue();
            
            return true;
        } else {
            console.error("游戏数据格式不正确!");
            displayText("错误：游戏数据格式不正确或没有可用段落。", "system-dialog");
            return false;
        }
    }
    
    /**
     * 初始化段落队列
     */
    function initializeParagraphQueue() {
        // 清空当前队列和显示历史
        currentState.paragraphQueue = [];
        currentState.displayedParagraphs = [];
        
        // 如果游戏数据包含预定义的段落序列，使用它
        if (gameData.paragraphSequence && gameData.paragraphSequence.length > 0) {
            console.log("使用预定义的段落序列");
            
            // 过滤掉可能存在的注释（以//开头的条目）
            const filteredSequence = gameData.paragraphSequence.filter(id => 
                typeof id === 'string' && !id.startsWith('//'));
            
            if (filteredSequence.length > 0) {
                currentState.paragraphQueue = [...filteredSequence];
            } else {
                // 如果过滤后没有有效段落，默认添加P001
                currentState.paragraphQueue = ["P001"];
            }
        }
        // 否则自动生成段落序列，从P001开始
        else if (gameData.paragraphs && gameData.paragraphs["P001"]) {
            console.log("从P001开始");
            currentState.paragraphQueue = ["P001"];
        }
        // 否则自动生成段落序列
        else {
            console.log("自动生成段落序列");
            
            // 获取所有P开头的段落ID并排序
            const paragraphIds = Object.keys(gameData.paragraphs)
                .filter(id => id.startsWith('P'))
                .sort((a, b) => {
                    const numA = parseInt(a.substring(1));
                    const numB = parseInt(b.substring(1));
                    return numA - numB;
                });
            
            console.log("所有普通段落ID:", paragraphIds);
            
            if (paragraphIds.length > 0) {
                // 只添加第一个段落到队列，其他段落会自动添加
                currentState.paragraphQueue = [paragraphIds[0]];
            } else {
                console.error("错误：找不到有效的起始段落！");
                // 使用一个占位符段落
                currentState.paragraphQueue = ["placeholder"];
            }
        }
        
        console.log("初始化段落队列:", currentState.paragraphQueue);
    }
    </script>
</body>
</html> 